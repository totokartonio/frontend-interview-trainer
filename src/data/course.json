{
  "title": "Frontend Interview Pro — Block 1: JavaScript Core",
  "duration": "7 дней",
  "lessonsPerWeek": 7,
  "totalLessons": 7,
  "lessons": [
    {
      "id": 1,
      "title": "Типы данных, примитивы, объекты и память",
      "duration": "140 мин",
      "theory": {
        "topics": [
          "Примитивные и ссылочные типы данных",
          "Работа памяти: stack vs heap",
          "Передача по значению и по ссылке",
          "Поверхностное и глубокое копирование"
        ],
        "content": "### Типы данных в JavaScript\n\nJavaScript — динамически типизированный язык. Тип проверяется **во время выполнения**, а не на этапе компиляции.\n\nЕсть две большие группы типов:\n\n1. **Примитивные типы**:\n   - `string`\n   - `number`\n   - `boolean`\n   - `null`\n   - `undefined`\n   - `symbol`\n   - `bigint`\n\n2. **Ссылочные типы**:\n   - `object`\n   - `array`\n   - `function`\n   - и все их подвиды (`Date`, `RegExp`, `Map`, `Set` и т.д.)\n\nПримитивы хранят **значение** напрямую, объекты — **ссылку** на область памяти.\n\n---\n\n### Примитивы\n\nПримитивы **иммутабельны**: любое \"изменение\" создаёт новое значение.\n\n```js\nlet a = 'hello';\nlet b = a;\n\nb = b.toUpperCase();\nconsole.log(a); // 'hello'\nconsole.log(b); // 'HELLO'\n```\n\n`a` и `b` — независимые значения в памяти.\n\n---\n\n### Объекты и массивы (ссылочные типы)\n\nОбъекты и массивы хранятся в **heap**, а переменная содержит ссылку:\n\n```js\nconst user1 = { name: 'Anna' };\nconst user2 = user1;\n\nuser2.name = 'Julia';\nconsole.log(user1.name); // 'Julia'\n```\n\nОбе переменные указывают на **один и тот же объект**.\n\n---\n\n### Stack vs Heap\n\n- **Stack** — примитивы, ссылки на объекты, контексты вызовов.\n- **Heap** — сами объекты и массивы, динамические структуры.\n\nВажно понимать это для вопросов про копирование и сравнение:\n\n```js\nconst a = { x: 1 };\nconst b = { x: 1 };\nconsole.log(a === b); // false — разные объекты в heap\n\nconst c = a;\nconsole.log(a === c); // true — одна и та же ссылка\n```\n\n---\n\n### Поверхностное и глубокое копирование\n\n**Поверхностная копия** копирует только верхний уровень свойств:\n\n```js\nconst original = { user: { name: 'Anna' }, age: 30 };\nconst shallow = { ...original };\n\nshallow.age = 31;\nconsole.log(original.age); // 30\n\nshallow.user.name = 'Julia';\nconsole.log(original.user.name); // 'Julia' — вложенный объект один и тот же\n```\n\n**Глубокая копия** создаёт новые объекты для всех уровней вложенности:\n\n```js\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item));\n  }\n\n  const result = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = deepClone(obj[key]);\n    }\n  }\n  return result;\n}\n\nconst deep = deepClone(original);\ndeep.user.name = 'Kate';\nconsole.log(original.user.name); // 'Julia' — уже не меняется\n```\n\n---\n\n### typeof и тонкости определения типа\n\n```js\ntypeof 42;          // 'number'\ntypeof 'hello';    // 'string'\ntypeof true;       // 'boolean'\ntypeof undefined;  // 'undefined'\ntypeof null;       // 'object' (исторический баг)\ntypeof Symbol();   // 'symbol'\ntypeof 10n;        // 'bigint'\n\ntypeof {};         // 'object'\ntypeof [];         // 'object'\ntypeof function() {} // 'function'\n```\n\nДля массивов и сложных структур используют:\n\n```js\nArray.isArray([]); // true\n\nObject.prototype.toString.call([]);      // '[object Array]'\nObject.prototype.toString.call(new Date()); // '[object Date]'\n```\n",
        "keyPoints": [
          "Примитивы передаются по значению, объекты — по ссылке",
          "Объекты и массивы живут в heap, а переменные хранят ссылки в stack",
          "Поверхностная копия не создаёт новые вложенные объекты",
          "Глубокая копия рекурсивно копирует вложенные структуры",
          "typeof имеет особенности: typeof null === 'object'"
        ]
      },
      "practice": [
        "Реализуйте функцию isPlainObject(value), которая возвращает true только для обычных объектов (не массивов, не дат и т.д.).",
        "Реализуйте функцию deepEqual(a, b), которая сравнивает два значения по содержимому (включая вложенные объекты и массивы).",
        "Напишите функцию cloneAndUpdate(user, newName), которая не мутирует исходный объект user, а возвращает новый объект с обновлённым полем name."
      ],
      "quiz": [
        {
          "id": 1,
          "question": "Что выведет код?\n\n```js\nlet a = 5;\nlet b = a;\n\nb = 10;\nconsole.log(a);\n```",
          "options": [
            {
              "id": "opt-1-1",
              "opt": "5"
            },
            {
              "id": "opt-1-2",
              "opt": "10"
            },
            {
              "id": "opt-1-3",
              "opt": "undefined"
            },
            {
              "id": "opt-1-4",
              "opt": "Будет ошибка"
            }
          ],
          "correctAnswer": "opt-1-1",
          "explanation": "Примитивы передаются по значению. Переменная b получила копию значения 5, изменение b не влияет на a."
        },
        {
          "id": 2,
          "question": "Что вернёт выражение `typeof null`?",
          "options": [
            {
              "id": "opt-2-1",
              "opt": "'null'"
            },
            {
              "id": "opt-2-2",
              "opt": "'object'"
            },
            {
              "id": "opt-2-3",
              "opt": "'undefined'"
            },
            {
              "id": "opt-2-4",
              "opt": "'boolean'"
            }
          ],
          "correctAnswer": "opt-2-2",
          "explanation": "Это историческая ошибка JavaScript: typeof null === 'object', оставленная для обратной совместимости."
        },
        {
          "id": 3,
          "question": "Как корректно проверить, что значение — массив?",
          "options": [
            {
              "id": "opt-3-1",
              "opt": "typeof value === 'array'"
            },
            {
              "id": "opt-3-2",
              "opt": "value instanceof Array"
            },
            {
              "id": "opt-3-3",
              "opt": "Array.isArray(value)"
            },
            {
              "id": "opt-3-4",
              "opt": "typeof value === 'object'"
            }
          ],
          "correctAnswer": "opt-3-3",
          "explanation": "Стандартный и надёжный способ — Array.isArray(value). instanceof может ломаться на разных iframes."
        },
        {
          "id": 4,
          "question": "Что выведет код?\n\n```js\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconsole.log(obj1 === obj2);\n```",
          "options": [
            {
              "id": "opt-4-1",
              "opt": "true"
            },
            {
              "id": "opt-4-2",
              "opt": "false"
            },
            {
              "id": "opt-4-3",
              "opt": "undefined"
            },
            {
              "id": "opt-4-4",
              "opt": "Будет ошибка"
            }
          ],
          "correctAnswer": "opt-4-2",
          "explanation": "Сравниваются ссылки на объекты в памяти. obj1 и obj2 указывают на разные объекты, даже если их содержимое одинаково."
        },
        {
          "id": 5,
          "question": "Что делает оператор spread при копировании объекта: `const copy = { ...original }`?",
          "options": [
            {
              "id": "opt-5-1",
              "opt": "Создаёт глубокую копию объекта"
            },
            {
              "id": "opt-5-2",
              "opt": "Создаёт поверхностную копию объекта"
            },
            {
              "id": "opt-5-3",
              "opt": "Ничего не копирует, только создаёт ссылку"
            },
            {
              "id": "opt-5-4",
              "opt": "Вызывает ошибку при вложенных объектах"
            }
          ],
          "correctAnswer": "opt-5-2",
          "explanation": "Spread создаёт только поверхностную копию: свойства верхнего уровня копируются, но вложенные объекты остаются теми же ссылками."
        }
      ]
    },
    {
      "id": 2,
      "title": "Область видимости, hoisting и Temporal Dead Zone",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Глобальная, функциональная и блочная область видимости",
          "var, let, const и их особенности",
          "Hoisting переменных и функций",
          "Temporal Dead Zone (TDZ)"
        ],
        "content": "### Область видимости (Scope)\n\nОбласть видимости — это зона кода, где переменная **доступна по имени**.\n\nОсновные виды:\n\n- **Глобальная** — переменные доступны везде.\n- **Функциональная** — создаётся при вызове функции.\n- **Блочная** — создаётся внутри `{ }` (if, for, while, block).\n\n---\n\n### var, let, const\n\n```js\nif (true) {\n  var x = 1;\n  let y = 2;\n  const z = 3;\n}\n\nconsole.log(x); // 1\nconsole.log(y); // ReferenceError\nconsole.log(z); // ReferenceError\n```\n\n- `var` — имеет **функциональную** область видимости.\n- `let` и `const` — **блочную** область видимости.\n\nТакже:\n- `var` можно повторно объявлять в одной и той же области.\n- `let`/`const` — нельзя.\n\n---\n\n### Hoisting (поднятие)\n\nВо время создания контекста выполнения интерпретатор сначала \"сканирует\" код и **поднимает объявления** переменных и функций.\n\n```js\nconsole.log(a); // undefined\nvar a = 10;\n\nconsole.log(b); // ReferenceError\nlet b = 20;\n```\n\n- Для `var` поднимается **объявление**, но не инициализация → значение `undefined`.\n- Для `let`/`const` объявление поднимается логически, но переменная остаётся в **TDZ**.\n\n**Hoisting функций**:\n\n```js\nsayHi(); // 'Hi'\n\nfunction sayHi() {\n  console.log('Hi');\n}\n```\n\nFunction Declaration поднимается целиком — можно вызывать до объявления.\n\n---\n\n### Temporal Dead Zone (TDZ)\n\nTDZ — это период между началом области видимости и строкой объявления `let`/`const`, когда переменная **уже существует логически**, но доступ к ней запрещён.\n\n```js\n{\n  // TDZ для переменной value\n  // Любая попытка обратиться к value здесь — ReferenceError\n\n  let value = 42; // конец TDZ\n  console.log(value); // 42\n}\n```\n\nПример, который часто задают на собеседовании:\n\n```js\nlet x = 1;\n\nfunction test() {\n  console.log(x); // ReferenceError, а не 1\n  let x = 2;\n}\n\ntest();\n```\n\nВнутри функции создаётся **новая** переменная x (let). Пока интерпретатор не дошёл до строки `let x = 2`, переменная x находится в TDZ. Поэтому обращение к `x` до объявления вызывает ошибку.\n\n---\n\n### Типичные ловушки с var\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}\n// 3, 3, 3\n```\n\nВсе три колбэка замкнулись на одну и ту же переменную `i` в функциональном scope, которая к моменту выполнения стала равна 3.\n\nРешение:\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0); // 0, 1, 2\n}\n```\n\nИли через IIFE:\n\n```js\nfor (var i = 0; i < 3; i++) {\n  (function(j) {\n    setTimeout(() => console.log(j), 0); // 0, 1, 2\n  })(i);\n}\n```\n",
        "keyPoints": [
          "var имеет функциональную область видимости, let/const — блочную",
          "Hoisting поднимает объявления, но не инициализации",
          "TDZ — период до объявления let/const, когда доступ к переменной запрещён",
          "Function Declaration полностью поднимается и доступна до объявления",
          "var легко приводит к багам в циклах и при повторных объявлениях"
        ]
      },
      "practice": [
        "Напишите пример кода, где использование var ломает логику в цикле, а затем перепишите его на let.",
        "Создайте функцию, внутри которой есть несколько вложенных блоков с переменными одинакового имени (let). Объясните, какие значения будут выведены.",
        "Перепишите небольшой скрипт (на ваш выбор) так, чтобы он использовал только let/const и не полагался на hoisting."
      ],
      "quiz": [
        {
          "id": 6,
          "question": "Что выведет код?\n\n```js\nconsole.log(a);\nvar a = 5;\n```",
          "options": [
            {
              "id": "opt-6-1",
              "opt": "5"
            },
            {
              "id": "opt-6-2",
              "opt": "undefined"
            },
            {
              "id": "opt-6-3",
              "opt": "ReferenceError"
            },
            {
              "id": "opt-6-4",
              "opt": "TypeError"
            }
          ],
          "correctAnswer": "opt-6-2",
          "explanation": "var поднимается, но инициализация происходит позже. На момент console.log переменная уже существует, но её значение — undefined."
        },
        {
          "id": 7,
          "question": "Что выведет код?\n\n```js\nconsole.log(b);\nlet b = 10;\n```",
          "options": [
            {
              "id": "opt-7-1",
              "opt": "10"
            },
            {
              "id": "opt-7-2",
              "opt": "undefined"
            },
            {
              "id": "opt-7-3",
              "opt": "ReferenceError"
            },
            {
              "id": "opt-7-4",
              "opt": "TypeError"
            }
          ],
          "correctAnswer": "opt-7-3",
          "explanation": "Переменная b находится в TDZ до строки let b = 10, доступ к ней запрещён — возникает ReferenceError."
        },
        {
          "id": 8,
          "question": "Какая область видимости у переменной, объявленной с var внутри функции?",
          "options": [
            {
              "id": "opt-8-1",
              "opt": "Блочная"
            },
            {
              "id": "opt-8-2",
              "opt": "Функциональная"
            },
            {
              "id": "opt-8-3",
              "opt": "Глобальная"
            },
            {
              "id": "opt-8-4",
              "opt": "Модульная"
            }
          ],
          "correctAnswer": "opt-8-2",
          "explanation": "var имеет функциональную область видимости: видна во всей функции, независимо от блоков if/for и т.д."
        },
        {
          "id": 9,
          "question": "Почему использование var в цикле с setTimeout часто приводит к неожиданным результатам?",
          "options": [
            {
              "id": "opt-9-1",
              "opt": "var нельзя использовать с setTimeout"
            },
            {
              "id": "opt-9-2",
              "opt": "var создаёт новую переменную на каждой итерации"
            },
            {
              "id": "opt-9-3",
              "opt": "var имеет функциональную область и одна переменная используется во всех итерациях"
            },
            {
              "id": "opt-9-4",
              "opt": "setTimeout не видит переменные var"
            }
          ],
          "correctAnswer": "opt-9-3",
          "explanation": "Из-за functional scope у var все колбэки замыкаются на одну переменную, которая к моменту выполнения цикла уже изменила своё значение."
        },
        {
          "id": 10,
          "question": "Какое утверждение про TDZ верно?",
          "options": [
            {
              "id": "opt-10-1",
              "opt": "TDZ относится только к var"
            },
            {
              "id": "opt-10-2",
              "opt": "TDZ возникает для let и const до строки объявления переменной"
            },
            {
              "id": "opt-10-3",
              "opt": "TDZ — это ошибка рантайма, которая не используется в современных браузерах"
            },
            {
              "id": "opt-10-4",
              "opt": "TDZ можно отключить в strict mode"
            }
          ],
          "correctAnswer": "opt-10-2",
          "explanation": "Для let и const переменная существует логически с начала блока, но доступ к ней до объявления запрещён — это и есть Temporal Dead Zone."
        }
      ]
    },
    {
      "id": 3,
      "title": "Функции, замыкания и лексическое окружение",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Function Declaration и Function Expression",
          "Arrow functions и контекст",
          "Замыкания (closures) и их применения",
          "Лексическое окружение и цепочка областей видимости"
        ],
        "content": "### Объявление функций\n\n**Function Declaration**:\n\n```js\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n- поднимается целиком (hoisting)\n- можно вызвать до объявления\n\n**Function Expression**:\n\n```js\nconst add = function (a, b) {\n  return a + b;\n};\n```\n\n- ведёт себя как обычная переменная\n- нельзя вызвать до присваивания\n\n**Arrow function**:\n\n```js\nconst add = (a, b) => a + b;\nconst square = x => x * x;\nconst greet = () => 'Hello';\n```\n\n- более короткий синтаксис\n- **не имеет собственного this, arguments, super, new.target**\n- не может быть конструктором\n\n---\n\n### Лексическое окружение (Lexical Environment)\n\nКаждая функция при создании запоминает **лексическое окружение**, в котором была объявлена.\n\n```js\nconst lang = 'JS';\n\nfunction outer() {\n  const framework = 'React';\n\n  function inner() {\n    console.log(lang, framework);\n  }\n\n  inner();\n}\n\nouter(); // 'JS React'\n```\n\nФункция `inner` имеет доступ к:\n- своим локальным переменным\n- переменным функции `outer`\n- глобальным переменным\n\n---\n\n### Замыкания (Closures)\n\n**Замыкание** — это функция + лексическое окружение, в котором эта функция была создана.\n\n```js\nfunction createCounter() {\n  let count = 0;\n\n  return function () {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n```\n\nФункция, возвращённая из `createCounter`, **запоминает** переменную `count` даже после завершения внешней функции.\n\nПрактические применения замыканий:\n\n- инкапсуляция и \"приватные\" данные\n- фабрики функций (function factories)\n- модульный паттерн\n- обработчики событий\n- колбэки в асинхронном коде\n\n---\n\n### Типичная ошибка с замыканиями в цикле\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}\n// 3, 3, 3\n```\n\nВсе стрелочные функции замыкаются на одну переменную `i` из внешней области.\n\nРешение 1 — использовать `let`:\n\n```js\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0); // 0, 1, 2\n}\n```\n\nРешение 2 — IIFE:\n\n```js\nfor (var i = 0; i < 3; i++) {\n  (function (j) {\n    setTimeout(() => console.log(j), 0);\n  })(i);\n}\n```\n\n---\n\n### IIFE (Immediately Invoked Function Expression)\n\n```js\n(function () {\n  const secret = 'hidden';\n  console.log('IIFE');\n})();\n```\n\nИспользуется для:\n- создания приватного scope\n- изоляции переменных\n- модульного паттерна в старом коде\n",
        "keyPoints": [
          "Function Declaration поднимается целиком, Function Expression — нет",
          "Arrow functions не имеют собственного this и arguments",
          "Замыкание позволяет функции запоминать переменные внешней области видимости",
          "Ошибка с var + setTimeout — классический пример неправильного замыкания",
          "IIFE создаёт изолированную область видимости и выполняется сразу"
        ]
      },
      "practice": [
        "Реализуйте функцию createCounter с методами increment, decrement и getValue, использующую замыкания (без классов).",
        "Напишите функцию once(fn), которая принимает функцию и возвращает новую, вызывающую fn только один раз, остальные вызовы игнорируются.",
        "Используя IIFE, создайте модуль, который хранит приватный массив и предоставляет методы addItem и getItems."
      ],
      "quiz": [
        {
          "id": 11,
          "question": "Что такое замыкание в JavaScript?",
          "options": [
            {
              "id": "opt-11-1",
              "opt": "Функция, которая вызывается сразу после объявления"
            },
            {
              "id": "opt-11-2",
              "opt": "Способ закрытия файла"
            },
            {
              "id": "opt-11-3",
              "opt": "Комбинация функции и лексического окружения, в котором эта функция была создана"
            },
            {
              "id": "opt-11-4",
              "opt": "Функция без имени"
            }
          ],
          "correctAnswer": "opt-11-3",
          "explanation": "Замыкание — это функция вместе с внешними переменными, к которым она продолжает иметь доступ даже после завершения внешнего кода."
        },
        {
          "id": 12,
          "question": "Что выведет код?\n\n```js\nfunction makeAdder(x) {\n  return function (y) {\n    return x + y;\n  };\n}\n\nconst add5 = makeAdder(5);\nconsole.log(add5(3));\n```",
          "options": [
            {
              "id": "opt-12-1",
              "opt": "3"
            },
            {
              "id": "opt-12-2",
              "opt": "5"
            },
            {
              "id": "opt-12-3",
              "opt": "8"
            },
            {
              "id": "opt-12-4",
              "opt": "NaN"
            }
          ],
          "correctAnswer": "opt-12-3",
          "explanation": "Внутренняя функция замыкается на x = 5 и получает аргумент y = 3, возвращая 5 + 3 = 8."
        },
        {
          "id": 13,
          "question": "Какое утверждение про arrow function верно?",
          "options": [
            {
              "id": "opt-13-1",
              "opt": "У неё есть свой this"
            },
            {
              "id": "opt-13-2",
              "opt": "Она может использоваться как конструктор с new"
            },
            {
              "id": "opt-13-3",
              "opt": "Она не имеет собственного this и берёт его из внешнего окружения"
            },
            {
              "id": "opt-13-4",
              "opt": "Её нельзя передавать как callback"
            }
          ],
          "correctAnswer": "opt-13-3",
          "explanation": "Основная особенность arrow function — отсутствие собственного this, оно лексически наследуется из внешнего scope."
        },
        {
          "id": 14,
          "question": "Зачем используют IIFE (Immediately Invoked Function Expression)?",
          "options": [
            {
              "id": "opt-14-1",
              "opt": "Чтобы создать глобальные переменные"
            },
            {
              "id": "opt-14-2",
              "opt": "Чтобы объявить функцию без имени, но не вызывать её"
            },
            {
              "id": "opt-14-3",
              "opt": "Чтобы создать отдельную область видимости и выполнить код сразу"
            },
            {
              "id": "opt-14-4",
              "opt": "Чтобы заменить setTimeout"
            }
          ],
          "correctAnswer": "opt-14-3",
          "explanation": "IIFE создаёт новый scope и тут же выполняется, изолируя переменные от внешнего кода."
        },
        {
          "id": 15,
          "question": "Почему следующий код выводит 3, 3, 3?\n\n```js\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}\n```",
          "options": [
            {
              "id": "opt-15-1",
              "opt": "Потому что setTimeout всегда выводит последнее значение"
            },
            {
              "id": "opt-15-2",
              "opt": "Потому что var имеет функциональную область, и все функции замкнулись на одну переменную i"
            },
            {
              "id": "opt-15-3",
              "opt": "Потому что стрелочные функции не работают с циклами"
            },
            {
              "id": "opt-15-4",
              "opt": "Это баг JavaScript"
            }
          ],
          "correctAnswer": "opt-15-2",
          "explanation": "var не создаёт новую переменную на каждой итерации, все колбэки разделяют одну i, которая после цикла равна 3."
        }
      ]
    },
    {
      "id": 4,
      "title": "this и контекст выполнения",
      "duration": "140 мин",
      "theory": {
        "topics": [
          "Четыре правила привязки this",
          "Явная и неявная привязка: call, apply, bind",
          "this в стрелочных функциях",
          "this в классах и методах объектов"
        ],
        "content": "### Что такое this\n\n`this` — это значение, которое определяется **в момент вызова функции**, а не в момент её объявления.\n\n---\n\n### 1. Привязка по умолчанию (default binding)\n\n```js\nfunction show() {\n  console.log(this);\n}\n\nshow();\n```\n\n- В строгом режиме (`'use strict'`) this будет `undefined`.\n- В нестрогом — глобальный объект (`window` в браузере).\n\n---\n\n### 2. Неявная привязка (implicit binding)\n\n```js\nconst user = {\n  name: 'Anna',\n  greet() {\n    console.log(this.name);\n  }\n};\n\nuser.greet(); // 'Anna'\n```\n\nКогда функция вызывается как метод объекта (`obj.method()`), this указывает на этот объект.\n\n**Потеря контекста:**\n\n```js\nconst greet = user.greet;\ngreet(); // undefined (в strict mode)\n```\n\nМы передали функцию отдельно, без объекта, и this больше не связан с user.\n\n---\n\n### 3. Явная привязка (explicit binding)\n\nМетоды **call, apply, bind** позволяют явно указать this.\n\n```js\nfunction showCity(country) {\n  console.log(this.name + ' from ' + country);\n}\n\nconst person = { name: 'Julia' };\n\nshowCity.call(person, 'Germany'); // 'Julia from Germany'\nshowCity.apply(person, ['Germany']);\n\nconst bound = showCity.bind(person, 'Germany');\nbound(); // 'Julia from Germany'\n```\n\n- `call(context, ...args)` — аргументы через запятую.\n- `apply(context, [args])` — аргументы массивом.\n- `bind(context, ...args)` — возвращает новую функцию с привязанным контекстом.\n\n---\n\n### 4. Привязка через new (new binding)\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nconst u = new User('Anna');\nconsole.log(u.name); // 'Anna'\n```\n\nПри вызове с `new`:\n- создаётся новый объект\n- this ссылается на этот объект\n- возвращается этот объект (если явно не вернуть другой)\n\n---\n\n### Приоритет правил привязки\n\nПорядок (от сильнейшего к слабейшему):\n\n1. `new` (new binding)\n2. `call` / `apply` / `bind` (explicit binding)\n3. `obj.method()` (implicit binding)\n4. обычный вызов (default binding)\n\n---\n\n### this в стрелочных функциях\n\nArrow function **не имеет собственного this**. Она берёт this из внешнего лексического окружения.\n\n```js\nconst obj = {\n  value: 42,\n  regular() {\n    console.log(this.value); // 42\n    const arrow = () => {\n      console.log(this.value); // 42 — тот же this\n    };\n    arrow();\n  },\n  arrow: () => {\n    console.log(this.value); // undefined — this глобальный\n  }\n};\n\nobj.regular();\nobj.arrow();\n```\n\nПоэтому **bind/call/apply** для стрелочных функций не меняют this.\n\n---\n\n### this в классах\n\n```js\nclass Counter {\n  constructor() {\n    this.value = 0;\n  }\n\n  increment() {\n    this.value++;\n  }\n}\n\nconst c = new Counter();\nconst inc = c.increment;\n// inc(); // this будет undefined, вызовет ошибку при обращении к this.value\n```\n\nРешение — привязать метод:\n\n```js\nthis.increment = this.increment.bind(this);\n```\n\nили использовать стрелочные методы (class fields):\n\n```js\nclass Counter {\n  value = 0;\n\n  increment = () => {\n    this.value++;\n  };\n}\n```\n",
        "keyPoints": [
          "Значение this определяется при вызове функции, а не при её объявлении",
          "Приоритет: new > explicit (call/apply/bind) > implicit (obj.method) > default",
          "Стрелочные функции не имеют собственного this и берут его из внешнего scope",
          "Потеря контекста происходит при передаче метода как callback",
          "bind создаёт новую функцию с жёстко привязанным контекстом"
        ]
      },
      "practice": [
        "Реализуйте свой собственный myBind(func, context, ...args), который работает аналогично Function.prototype.bind.",
        "Создайте объект с несколькими методами и продемонстрируйте случаи потери контекста и способы их решения (bind, стрелочные функции, обёртки).",
        "Напишите класс с методами, один из которых передаётся как обработчик события. Покажите, как сохранить корректный this внутри обработчика."
      ],
      "quiz": [
        {
          "id": 16,
          "question": "Какое правило привязки this имеет самый высокий приоритет?",
          "options": [
            {
              "id": "opt-16-1",
              "opt": "Неявная привязка (obj.method())"
            },
            {
              "id": "opt-16-2",
              "opt": "Привязка по умолчанию"
            },
            {
              "id": "opt-16-3",
              "opt": "Явная привязка (call/apply/bind)"
            },
            {
              "id": "opt-16-4",
              "opt": "Привязка через new"
            }
          ],
          "correctAnswer": "opt-16-4",
          "explanation": "new binding имеет самый высокий приоритет: если функция вызвана с new, this всегда будет новым объектом, даже если к ней применён bind."
        },
        {
          "id": 17,
          "question": "Что выведет код в strict mode?\n\n```js\nfunction show() {\n  console.log(this);\n}\n\nshow();\n```",
          "options": [
            {
              "id": "opt-17-1",
              "opt": "window"
            },
            {
              "id": "opt-17-2",
              "opt": "undefined"
            },
            {
              "id": "opt-17-3",
              "opt": "global object"
            },
            {
              "id": "opt-17-4",
              "opt": "{}"
            }
          ],
          "correctAnswer": "opt-17-2",
          "explanation": "В strict mode при обычном вызове функции this === undefined."
        },
        {
          "id": 18,
          "question": "Чем отличается call от apply?",
          "options": [
            {
              "id": "opt-18-1",
              "opt": "call принимает аргументы по одному, apply — массивом"
            },
            {
              "id": "opt-18-2",
              "opt": "apply работает только со стрелочными функциями"
            },
            {
              "id": "opt-18-3",
              "opt": "apply не может менять this"
            },
            {
              "id": "opt-18-4",
              "opt": "Разницы нет, это синонимы"
            }
          ],
          "correctAnswer": "opt-18-1",
          "explanation": "Оба метода устанавливают this, но сигнатура разная: call(...args), apply([args])."
        },
        {
          "id": 19,
          "question": "Почему стрелочную функцию нельзя использовать как конструктор с new?",
          "options": [
            {
              "id": "opt-19-1",
              "opt": "Потому что у неё нет прототипа"
            },
            {
              "id": "opt-19-2",
              "opt": "Потому что у неё нет собственного this и new.target"
            },
            {
              "id": "opt-19-3",
              "opt": "Потому что она всегда возвращает undefined"
            },
            {
              "id": "opt-19-4",
              "opt": "На самом деле можно, это валидный код"
            }
          ],
          "correctAnswer": "opt-19-2",
          "explanation": "Arrow function специально сделана не-конструктором: у неё нет своего this и new.target, попытка вызвать с new приводит к ошибке."
        },
        {
          "id": 20,
          "question": "Что выведет код?\n\n```js\nconst obj = {\n  name: 'Anna',\n  getName() {\n    return this.name;\n  }\n};\n\nconst get = obj.getName;\nconsole.log(get());\n```",
          "options": [
            {
              "id": "opt-20-1",
              "opt": "'Anna'"
            },
            {
              "id": "opt-20-2",
              "opt": "undefined (в strict mode)"
            },
            {
              "id": "opt-20-3",
              "opt": "window.name"
            },
            {
              "id": "opt-20-4",
              "opt": "Будет ошибка компиляции"
            }
          ],
          "correctAnswer": "opt-20-2",
          "explanation": "Контекст теряется при передаче метода в переменную. В strict mode this === undefined, поэтому get() возвращает undefined."
        }
      ]
    },
    {
      "id": 5,
      "title": "Прототипы, наследование и Object API",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Внутреннее свойство [[Prototype]] и __proto__",
          "Цепочка прототипов (prototype chain)",
          "Object.create, Object.getPrototypeOf, Object.setPrototypeOf",
          "Методы для работы со свойствами и прототипами"
        ],
        "content": "### [[Prototype]] и прототипное наследование\n\nКаждый объект в JavaScript имеет внутреннее свойство `[[Prototype]]`, которое ссылается на другой объект (или null).\n\n```js\nconst parent = { greet() { console.log('Hello'); } };\nconst child = Object.create(parent);\n\nchild.greet(); // 'Hello'\n```\n\nЕсли свойство не найдено у самого объекта, поиск продолжается по цепочке прототипов.\n\n---\n\n### .prototype vs [[Prototype]]\n\n- `obj.[[Prototype]]` — внутреннее свойство объекта.\n- `Func.prototype` — объект, который станет прототипом для всех экземпляров, созданных через `new Func()`.\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.sayHi = function () {\n  console.log('Hi, ' + this.name);\n};\n\nconst u = new User('Anna');\nu.sayHi(); // 'Hi, Anna'\n```\n\nЗдесь:\n- `User.prototype` — общий объект-прототип.\n- `u.[[Prototype]] === User.prototype`.\n\n---\n\n### Object.create\n\n```js\nconst animal = {\n  speak() {\n    console.log(this.name + ' makes a sound');\n  }\n};\n\nconst dog = Object.create(animal);\ndog.name = 'Rex';\ndog.speak(); // 'Rex makes a sound'\n```\n\n`Object.create(proto)` создаёт новый объект с указанным прототипом.\n\n---\n\n### Object.getPrototypeOf и Object.setPrototypeOf\n\n```js\nconst proto = { kind: 'animal' };\nconst cat = Object.create(proto);\ncat.name = 'Murka';\n\nconsole.log(Object.getPrototypeOf(cat) === proto); // true\n\nconst newProto = { kind: 'robot' };\nObject.setPrototypeOf(cat, newProto);\nconsole.log(Object.getPrototypeOf(cat) === newProto); // true\n```\n\n`__proto__` — устаревший, но распространённый геттер/сеттер для прототипа:\n\n```js\ncat.__proto__ = proto; // делать так не рекомендуется\n```\n\n---\n\n### Конструкторы и наследование\n\n```js\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function () {\n  console.log(this.name + ' makes a sound');\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, name); // наследуем свойства\n  this.breed = breed;\n}\n\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nDog.prototype.bark = function () {\n  console.log(this.name + ' barks');\n};\n\nconst d = new Dog('Rex', 'Labrador');\nd.speak(); // 'Rex makes a sound'\nd.bark();  // 'Rex barks'\n```\n\n---\n\n### Методы Object.* для работы со свойствами\n\n```js\nconst user = { name: 'Anna', age: 30 };\n\nObject.keys(user);              // ['name', 'age']\nObject.values(user);            // ['Anna', 30]\nObject.entries(user);           // [['name', 'Anna'], ['age', 30]]\n\nuser.hasOwnProperty('name');    // true\n\nObject.getOwnPropertyNames(user); // ['name', 'age']\n\nObject.defineProperty(user, 'id', {\n  value: 1,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n```\n\n---\n\n### instanceof\n\n```js\nfunction Animal() {}\nconst a = new Animal();\n\nconsole.log(a instanceof Animal); // true\nconsole.log(a instanceof Object); // true\n```\n\n`instanceof` проверяет, присутствует ли `Func.prototype` в цепочке прототипов объекта.\n",
        "keyPoints": [
          "У каждого объекта есть [[Prototype]], который может указывать на другой объект или null",
          "Prototype chain используется при поиске свойств",
          "Object.create создаёт объект с заданным прототипом",
          "Функции-конструкторы используют свойство prototype для общих методов",
          "instanceof проверяет наличие prototype функции в цепочке прототипов объекта"
        ]
      },
      "practice": [
        "Создайте цепочку прототипов: LivingThing -> Animal -> Dog, где каждый уровень добавляет свой метод.",
        "Реализуйте функцию myInstanceOf(obj, Constructor), которая работает аналогично оператору instanceof.",
        "Создайте объект с несколькими свойствами, сделайте одно свойство неперечислимым через Object.defineProperty и проверьте, как оно ведёт себя в цикле for...in."
      ],
      "quiz": [
        {
          "id": 21,
          "question": "Что делает Object.create(proto)?",
          "options": [
            {
              "id": "opt-21-1",
              "opt": "Клонирует объект proto"
            },
            {
              "id": "opt-21-2",
              "opt": "Создаёт новый объект с [[Prototype]], указывающим на proto"
            },
            {
              "id": "opt-21-3",
              "opt": "Удаляет прототип у proto"
            },
            {
              "id": "opt-21-4",
              "opt": "Изменяет prototype функции"
            }
          ],
          "correctAnswer": "opt-21-2",
          "explanation": "Object.create создаёт новый объект, чей [[Prototype]] равен переданному аргументу proto."
        },
        {
          "id": 22,
          "question": "Что будет в конце цепочки прототипов любого обычного объекта?",
          "options": [
            {
              "id": "opt-22-1",
              "opt": "undefined"
            },
            {
              "id": "opt-22-2",
              "opt": "null"
            },
            {
              "id": "opt-22-3",
              "opt": "Object"
            },
            {
              "id": "opt-22-4",
              "opt": "Function"
            }
          ],
          "correctAnswer": "opt-22-2",
          "explanation": "Object.prototype.__proto__ === null, поэтому null — конец цепочки прототипов."
        },
        {
          "id": 23,
          "question": "Что вернёт выражение?\n\n```js\nfunction Foo() {}\nconst f = new Foo();\nconsole.log(f instanceof Foo);\n```",
          "options": [
            {
              "id": "opt-23-1",
              "opt": "true"
            },
            {
              "id": "opt-23-2",
              "opt": "false"
            },
            {
              "id": "opt-23-3",
              "opt": "undefined"
            },
            {
              "id": "opt-23-4",
              "opt": "Будет ошибка"
            }
          ],
          "correctAnswer": "opt-23-1",
          "explanation": "f создан через new Foo, поэтому в его цепочке прототипов присутствует Foo.prototype, instanceof вернёт true."
        },
        {
          "id": 24,
          "question": "Как корректно получить прототип объекта obj?",
          "options": [
            {
              "id": "opt-24-1",
              "opt": "obj.prototype"
            },
            {
              "id": "opt-24-2",
              "opt": "obj.__proto__"
            },
            {
              "id": "opt-24-3",
              "opt": "Object.getPrototypeOf(obj)"
            },
            {
              "id": "opt-24-4",
              "opt": "obj[[Prototype]]"
            }
          ],
          "correctAnswer": "opt-24-3",
          "explanation": "Стандартизированный способ — Object.getPrototypeOf(obj). __proto__ поддерживается, но считается устаревшим."
        },
        {
          "id": 25,
          "question": "Что выведет код?\n\n```js\nfunction A() {}\nfunction B() {}\n\nB.prototype = Object.create(A.prototype);\n\nconst b = new B();\nconsole.log(b instanceof A);\n```",
          "options": [
            {
              "id": "opt-25-1",
              "opt": "true"
            },
            {
              "id": "opt-25-2",
              "opt": "false"
            },
            {
              "id": "opt-25-3",
              "opt": "undefined"
            },
            {
              "id": "opt-25-4",
              "opt": "Будет ошибка"
            }
          ],
          "correctAnswer": "opt-25-1",
          "explanation": "Цепочка прототипов b включает A.prototype, поэтому b instanceof A === true."
        }
      ]
    },
    {
      "id": 6,
      "title": "Асинхронность, event loop и promises",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Синхронный и асинхронный код",
          "Event loop, call stack, task queue и microtask queue",
          "Promises и async/await",
          "Последовательное и параллельное выполнение"
        ],
        "content": "### Синхронный vs асинхронный код\n\nСинхронный код выполняется построчно, блокируя дальнейшее выполнение, пока операция не завершится.\n\nАсинхронный код позволяет браузеру не блокировать основной поток: операции (запросы, таймеры) выполняются \"в фоне\", а результат обрабатывается позже через callback или promise.\n\n---\n\n### Event loop (цикл событий)\n\nУпрощённая модель:\n\n- **Call stack** — стек вызовов, где выполняется ваш JS-код.\n- **Heap** — память для объектов.\n- **Task queue (macrotask queue)** — очередь задач (setTimeout, setInterval, события DOM и т.д.).\n- **Microtask queue** — очередь микрозадач (обработчики promises: then/catch/finally).\n\nПорядок:\n1. Выполняется весь синхронный код в call stack.\n2. Затем event loop берёт **все микрозадачи** из microtask queue и выполняет их.\n3. После этого берётся **одна** задача из task queue (macrotask), выполняется.\n4. Снова микрозадачи и т.д.\n\n---\n\n### Пример с setTimeout и promise\n\n```js\nconsole.log('start');\n\nsetTimeout(() => console.log('timeout'), 0);\n\nPromise.resolve()\n  .then(() => console.log('microtask'));\n\nconsole.log('end');\n```\n\nПорядок вывода:\n\n1. `start` — синхронный код\n2. `end` — синхронный код\n3. `microtask` — microtask queue (promise)\n4. `timeout` — macrotask queue (setTimeout)\n\n---\n\n### Promises\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('done');\n  }, 1000);\n});\n\npromise\n  .then(result => console.log(result))\n  .catch(error => console.error(error))\n  .finally(() => console.log('finished'));\n```\n\nСостояния promise:\n- pending\n- fulfilled\n- rejected\n\n---\n\n### async / await\n\n`async` автоматически оборачивает возвращаемое значение в promise.\n\n```js\nasync function getData() {\n  return 42;\n}\n\ngetData().then(console.log); // 42\n```\n\n`await` приостанавливает выполнение внутри async-функции, пока promise не завершится.\n\n```js\nasync function load() {\n  console.log('before');\n  const value = await Promise.resolve(10);\n  console.log('value:', value);\n}\n\nload();\nconsole.log('after');\n```\n\nПорядок:\n- before\n- after\n- value: 10\n\n---\n\n### Последовательное и параллельное выполнение promises\n\nПоследовательно:\n\n```js\nasync function sequential() {\n  const a = await fetch('/a');\n  const b = await fetch('/b');\n}\n```\n\nПараллельно:\n\n```js\nasync function parallel() {\n  const [a, b] = await Promise.all([\n    fetch('/a'),\n    fetch('/b')\n  ]);\n}\n```\n\n---\n\n### Ошибки и обработка\n\nПри использовании async/await ошибки ловятся через try/catch:\n\n```js\nasync function loadData() {\n  try {\n    const res = await fetch('/api');\n    if (!res.ok) {\n      throw new Error('Request failed');\n    }\n    const data = await res.json();\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error; // пробрасываем дальше, если нужно\n  }\n}\n```\n",
        "keyPoints": [
          "Сначала выполняется весь синхронный код, затем microtasks (promises), потом macrotasks (setTimeout и т.п.)",
          "Promise имеет состояния: pending, fulfilled, rejected",
          "async функция всегда возвращает promise",
          "await приостанавливает выполнение внутри async-функции, не блокируя основной поток",
          "Promise.all позволяет выполнять несколько запросов параллельно"
        ]
      },
      "practice": [
        "Напишите функцию delay(ms), возвращающую promise, который резолвится через ms миллисекунд, и продемонстрируйте её использование с async/await.",
        "Реализуйте функцию loadInParallel(urls), которая принимает массив URL и возвращает массив результатов, используя Promise.all.",
        "Напишите функцию, которая делает три запроса последовательно и три запроса параллельно, и выведите разницу по времени (можно замерять через console.time)."
      ],
      "quiz": [
        {
          "id": 26,
          "question": "Что будет выведено в консоль?\n\n```js\nconsole.log('A');\n\nsetTimeout(() => console.log('B'), 0);\n\nPromise.resolve().then(() => console.log('C'));\n\nconsole.log('D');\n```",
          "options": [
            {
              "id": "opt-26-1",
              "opt": "A, B, C, D"
            },
            {
              "id": "opt-26-2",
              "opt": "A, D, B, C"
            },
            {
              "id": "opt-26-3",
              "opt": "A, D, C, B"
            },
            {
              "id": "opt-26-4",
              "opt": "A, C, D, B"
            }
          ],
          "correctAnswer": "opt-26-3",
          "explanation": "Сначала синхронный код (A, D), затем microtask (C), затем macrotask (B)."
        },
        {
          "id": 27,
          "question": "Что возвращает async-функция, если внутри неё явно вернуть число?",
          "options": [
            {
              "id": "opt-27-1",
              "opt": "Число"
            },
            {
              "id": "opt-27-2",
              "opt": "Promise, который резолвится в это число"
            },
            {
              "id": "opt-27-3",
              "opt": "undefined"
            },
            {
              "id": "opt-27-4",
              "opt": "Всегда rejected promise"
            }
          ],
          "correctAnswer": "opt-27-2",
          "explanation": "Любая async-функция всегда возвращает promise. Если вернуть число, оно оборачивается в resolved promise."
        },
        {
          "id": 28,
          "question": "Какой метод позволяет запустить несколько promises параллельно и дождаться всех?",
          "options": [
            {
              "id": "opt-28-1",
              "opt": "Promise.race"
            },
            {
              "id": "opt-28-2",
              "opt": "Promise.all"
            },
            {
              "id": "opt-28-3",
              "opt": "Promise.any"
            },
            {
              "id": "opt-28-4",
              "opt": "Promise.resolve"
            }
          ],
          "correctAnswer": "opt-28-2",
          "explanation": "Promise.all ждёт выполнения всех promises и возвращает массив результатов или ошибку при первом reject."
        },
        {
          "id": 29,
          "question": "Где выполняются then/catch обработчики promise?",
          "options": [
            {
              "id": "opt-29-1",
              "opt": "В call stack сразу при создании promise"
            },
            {
              "id": "opt-29-2",
              "opt": "В microtask queue после завершения текущего синхронного кода"
            },
            {
              "id": "opt-29-3",
              "opt": "В macrotask queue вместе с setTimeout"
            },
            {
              "id": "opt-29-4",
              "opt": "В отдельном потоке браузера"
            }
          ],
          "correctAnswer": "opt-29-2",
          "explanation": "Обработчики then/catch/finally попадают в очередь микрозадач (microtask queue) и выполняются после синхронного кода, но до macrotasks."
        },
        {
          "id": 30,
          "question": "Что произойдёт, если в async-функции выбросить исключение (throw new Error)?",
          "options": [
            {
              "id": "opt-30-1",
              "opt": "Приложение всегда упадёт"
            },
            {
              "id": "opt-30-2",
              "opt": "Это будет эквивалентно вызову reject у возвращаемого promise"
            },
            {
              "id": "opt-30-3",
              "opt": "Ошибка проигнорируется"
            },
            {
              "id": "opt-30-4",
              "opt": "Функция вернёт undefined"
            }
          ],
          "correctAnswer": "opt-30-2",
          "explanation": "Внутри async-функции throw превращается в rejected promise, который можно обработать через try/catch или .catch."
        }
      ]
    },
    {
      "id": 7,
      "title": "Работа с API, fetch и архитектура запросов",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "fetch и обработка ответов",
          "Обработка ошибок и статус-кодов",
          "Последовательные и параллельные запросы",
          "Выделение API-слоя и чистые функции"
        ],
        "content": "### Базовый пример fetch\n\n```js\nfetch('/api/users')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error('Network error: ' + response.status);\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log(data);\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  });\n```\n\nВажно:\n- проверять `response.ok` и `response.status`\n- парсить тело (`response.json()`, `response.text()`)\n- обрабатывать ошибки в `.catch`\n\n---\n\n### async/await с fetch\n\n```js\nasync function loadUsers() {\n  try {\n    const res = await fetch('/api/users');\n    if (!res.ok) {\n      throw new Error('Request failed: ' + res.status);\n    }\n    const data = await res.json();\n    return data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n```\n\n---\n\n### Последовательные и параллельные запросы\n\nПоследовательно (когда второй запрос зависит от первого):\n\n```js\nasync function loadUserWithPosts(id) {\n  const userRes = await fetch('/api/users/' + id);\n  const user = await userRes.json();\n\n  const postsRes = await fetch('/api/users/' + id + '/posts');\n  const posts = await postsRes.json();\n\n  return { user, posts };\n}\n```\n\nПараллельно (когда запросы независимы):\n\n```js\nasync function loadDashboard() {\n  const [usersRes, statsRes] = await Promise.all([\n    fetch('/api/users'),\n    fetch('/api/stats')\n  ]);\n\n  const [users, stats] = await Promise.all([\n    usersRes.json(),\n    statsRes.json()\n  ]);\n\n  return { users, stats };\n}\n```\n\n---\n\n### AbortController: отмена запросов\n\n```js\nconst controller = new AbortController();\nconst { signal } = controller;\n\nfetch('/api/slow', { signal })\n  .then(res => res.json())\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Request aborted');\n    } else {\n      console.error(error);\n    }\n  });\n\n// где-то позже\ncontroller.abort();\n```\n\nВ React это полезно для отмены запросов при размонтировании компонента или смене параметров.\n\n---\n\n### Архитектура: API-слой\n\nВместо того чтобы вызывать fetch прямо в компонентах, лучше выделить **отдельный модуль** для работы с API.\n\n```js\n// api/client.js\nconst BASE_URL = '/api';\n\nasync function request(path, options = {}) {\n  const res = await fetch(BASE_URL + path, {\n    headers: { 'Content-Type': 'application/json' },\n    ...options\n  });\n\n  if (!res.ok) {\n    const errorText = await res.text().catch(() => '');\n    throw new Error('API error ' + res.status + ': ' + errorText);\n  }\n\n  const contentType = res.headers.get('Content-Type') || '';\n  if (contentType.includes('application/json')) {\n    return res.json();\n  }\n  return res.text();\n}\n\nexport const apiClient = {\n  get(path) {\n    return request(path);\n  },\n  post(path, body) {\n    return request(path, {\n      method: 'POST',\n      body: JSON.stringify(body)\n    });\n  }\n};\n```\n\n```js\n// api/users.js\nimport { apiClient } from './client';\n\nexport function getUsers() {\n  return apiClient.get('/users');\n}\n\nexport function createUser(payload) {\n  return apiClient.post('/users', payload);\n}\n```\n\nТакой подход:\n- изолирует детали работы с сетью\n- упрощает тестирование (можно мокать apiClient)\n- делает компоненты \"чистыми\" (они работают с данными, а не с HTTP)\n",
        "keyPoints": [
          "fetch возвращает promise с объектом Response, нужно явно проверять response.ok",
          "async/await упрощает чтение асинхронного кода, но ошибки всё равно нужно оборачивать в try/catch",
          "Promise.all позволяет запускать независимые запросы параллельно",
          "AbortController даёт возможность отменять запросы, что важно для UI",
          "Выделение API-слоя упрощает архитектуру приложения и тестирование"
        ]
      },
      "practice": [
        "Создайте модуль apiClient с методами get/post и используйте его для запросов к публичному API (или моковому URL).",
        "Напишите функцию loadUserProfile(id), которая загружает пользователя и его посты: запросы к /users/:id и /users/:id/posts должны выполняться последовательно.",
        "Реализуйте функцию loadDashboard(), выполняющую запросы к /stats и /notifications параллельно с помощью Promise.all."
      ],
      "quiz": [
        {
          "id": 31,
          "question": "Что верно про fetch по умолчанию?",
          "options": [
            {
              "id": "opt-31-1",
              "opt": "Он отклоняет promise (reject), если сервер вернул 404"
            },
            {
              "id": "opt-31-2",
              "opt": "Он всегда возвращает JSON"
            },
            {
              "id": "opt-31-3",
              "opt": "Он отклоняет promise только при сетевой ошибке (нет сети и т.п.)"
            },
            {
              "id": "opt-31-4",
              "opt": "Он автоматически повторяет запрос при ошибке"
            }
          ],
          "correctAnswer": "opt-31-3",
          "explanation": "fetch делает reject только при сетевой ошибке. Коды 4xx/5xx считаются успешным ответом, требуется ручная проверка response.ok."
        },
        {
          "id": 32,
          "question": "Как правильно проверить, что HTTP-запрос прошёл успешно?",
          "options": [
            {
              "id": "opt-32-1",
              "opt": "if (response.status === 200)"
            },
            {
              "id": "opt-32-2",
              "opt": "if (response.ok)"
            },
            {
              "id": "opt-32-3",
              "opt": "if (response)"
            },
            {
              "id": "opt-32-4",
              "opt": "if (!response.error)"
            }
          ],
          "correctAnswer": "opt-32-2",
          "explanation": "Свойство response.ok === true для статус-кодов 200–299, это удобная и рекомендуемая проверка успешного ответа."
        },
        {
          "id": 33,
          "question": "Какой плюс у выделения API-слоя (отдельного модуля для запросов)?",
          "options": [
            {
              "id": "opt-33-1",
              "opt": "Компоненты могут напрямую работать с fetch"
            },
            {
              "id": "opt-33-2",
              "opt": "Проще централизованно обрабатывать ошибки и заголовки"
            },
            {
              "id": "opt-33-3",
              "opt": "Это обязательно для работы React"
            },
            {
              "id": "opt-33-4",
              "opt": "Это ускоряет сеть на уровне браузера"
            }
          ],
          "correctAnswer": "opt-33-2",
          "explanation": "API-слой позволяет в одном месте настраивать заголовки, обработку ошибок, логирование, токены авторизации и т.д."
        },
        {
          "id": 34,
          "question": "Для чего используется AbortController при работе с fetch?",
          "options": [
            {
              "id": "opt-34-1",
              "opt": "Для повторного отправления запроса"
            },
            {
              "id": "opt-34-2",
              "opt": "Для отмены запроса до его завершения"
            },
            {
              "id": "opt-34-3",
              "opt": "Для автоматического парсинга JSON"
            },
            {
              "id": "opt-34-4",
              "opt": "Для кеширования ответа"
            }
          ],
          "correctAnswer": "opt-34-2",
          "explanation": "AbortController даёт сигнал, по которому fetch может быть отменён, что важно при уходе со страницы или смене параметров запроса."
        },
        {
          "id": 35,
          "question": "Как лучше всего запустить два независимых запроса параллельно и обработать оба результата?",
          "options": [
            {
              "id": "opt-35-1",
              "opt": "Сделать второй запрос в then первого"
            },
            {
              "id": "opt-35-2",
              "opt": "Использовать два отдельных await подряд в async-функции"
            },
            {
              "id": "opt-35-3",
              "opt": "Использовать Promise.all с массивом promises"
            },
            {
              "id": "opt-35-4",
              "opt": "Параллельные запросы невозможны в JS"
            }
          ],
          "correctAnswer": "opt-35-3",
          "explanation": "Promise.all позволяет запустить оба запроса одновременно и получить результаты, когда оба завершатся."
        }
      ]
    },
    {
      "id": 8,
      "title": "HTML5: структура, семантика и доступность (A11y)",
      "duration": "140 мин",
      "theory": {
        "topics": [
          "Базовая структура HTML-документа",
          "Семантические теги HTML5",
          "Формы, label и связь с полями",
          "Alt-текст, aria-* атрибуты и фокус",
          "Основы доступности (A11y) для фронтенд-разработчика"
        ],
        "content": "### Базовая структура HTML-документа\n\nМинимальный HTML-документ:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <!-- Контент страницы -->\n  </body>\n</html>\n```\n\nКлючевые моменты:\n- `<!DOCTYPE html>` — говорит браузеру использовать современный стандарт HTML5.\n- `lang` на `<html>` важно для доступности и SEO.\n- `meta charset=\"UTF-8\"` — корректное отображение символов.\n- `meta name=\"viewport\"` — адаптивная вёрстка для мобильных.\n\n---\n\n### Семантические теги HTML5\n\nСемантика помогает:\n- сделать структуру понятной для людей,\n- улучшить доступность для скринридеров,\n- помочь поисковикам.\n\nЧасто используемые семантические теги:\n\n- `<header>` — шапка страницы или секции.\n- `<nav>` — основная навигация.\n- `<main>` — главный уникальный контент страницы.\n- `<section>` — логические разделы.\n- `<article>` — независимый, самодостаточный контент.\n- `<aside>` — боковые блоки: сайдбар, дополнительная информация.\n- `<footer>` — подвал страницы или секции.\n\nПример структуры страницы:\n\n```html\n<body>\n  <header>\n    <nav>...</nav>\n  </header>\n  <main>\n    <article>\n      <h1>Заголовок статьи</h1>\n      <p>Текст...</p>\n    </article>\n    <aside>\n      Боковая информация\n    </aside>\n  </main>\n  <footer>\n    &copy; 2025\n  </footer>\n</body>\n```\n\n---\n\n### Формы, label и связь с полями\n\nДля доступности важно корректно связывать поле ввода и подпись к нему.\n\n```html\n<form>\n  <label for=\"email\">Email</label>\n  <input id=\"email\" name=\"email\" type=\"email\" />\n\n  <label>\n    <input type=\"checkbox\" name=\"agree\" />\n    Я согласен с условиями\n  </label>\n</form>\n```\n\nДва варианта:\n- через `for` + `id`,\n- через вложенный `input` внутрь `label`.\n\nЭто позволяет:\n- кликать по тексту label, чтобы активировать поле,\n- корректно озвучивать поле скринридерам.\n\n---\n\n### Alt для изображений\n\nАтрибут `alt` описывает изображение для тех, кто не видит его:\n\n```html\n<img src=\"hotel.jpg\" alt=\"Фасад отеля ночью с подсветкой\" />\n```\n\nРекомендации:\n- если картинка несёт смысл — описать смысл.\n- если картинка декоративная — `alt=\"\"` или фон через CSS.\n\nПлохой пример: `alt=\"image\"` — бесполезно.\n\n---\n\n### aria-* атрибуты и фокус\n\nARIA (Accessible Rich Internet Applications) помогает делать сложные интерфейсы доступными:\n\n- `role` — роль элемента (button, dialog, navigation и т.п.).\n- `aria-label` — текстовая подпись для элемента.\n- `aria-hidden=\"true\"` — скрыть от скринридера.\n\nПример кастомной кнопки:\n\n```html\n<div\n  role=\"button\"\n  tabindex=\"0\"\n  aria-label=\"Открыть меню\"\n>\n  ☰\n</div>\n```\n\nВажно:\n- использовать `tabindex=\"0\"`, чтобы элемент фокусировался по Tab.\n- обеспечивать управление с клавиатуры (Enter/Space).\n\n---\n\n### Основы доступности (A11y)\n\nМинимальный чек-лист фронтендера:\n\n- все интерактивные элементы доступны с клавиатуры (Tab, Enter, Space).\n- у форм есть `label`.\n- у изображений с смыслом есть корректный `alt`.\n- цветовой контраст текста и фона достаточный (WCAG рекомендует контраст не менее 4.5:1 для обычного текста).\n- один основной `<main>` на странице.\n- заголовки идут по уровню (`h1` → `h2` → `h3`...).\n",
        "keyPoints": [
          "Семантическая структура улучшает доступность и понятность кода",
          "Тег main должен быть один и содержать основной контент страницы",
          "label должен быть связан с input через for/id или вложенность",
          "alt обязателен для значимых изображений, для декоративных — alt=\"\"",
          "ARIA атрибуты дополняют, но не заменяют корректную семантику HTML"
        ]
      },
      "practice": [
        "Сверстайте простую страницу профиля (аватар, имя, описание, список ссылок) с использованием семантических тегов header, main, section, footer.",
        "Добавьте форму подписки на новости (email + чекбокс согласия), корректно связав все поля с label и подумав о доступности.",
        "Возьмите любую вашу существующую страницу и перепроверьте её на семантику и доступность: main, структура заголовков, alt, фокус, управление с клавиатуры."
      ],
      "quiz": [
        {
          "id": 36,
          "question": "Для чего используется тег <main>?",
          "options": [
            {
              "id": "opt-36-1",
              "opt": "Для шапки сайта"
            },
            {
              "id": "opt-36-2",
              "opt": "Для основного уникального контента страницы"
            },
            {
              "id": "opt-36-3",
              "opt": "Для боковой колонки"
            },
            {
              "id": "opt-36-4",
              "opt": "Для группировки ссылок навигации"
            }
          ],
          "correctAnswer": "opt-36-2",
          "explanation": "Тег <main> должен содержать основной уникальный контент страницы. Он должен быть только один и не включать в себя header, footer, nav и др."
        },
        {
          "id": 37,
          "question": "Какой alt лучше всего подходит для значимого изображения?",
          "options": [
            {
              "id": "opt-37-1",
              "opt": "alt=\"image\""
            },
            {
              "id": "opt-37-2",
              "opt": "alt=\"\""
            },
            {
              "id": "opt-37-3",
              "opt": "alt=\"Фасад отеля ночью с подсветкой\""
            },
            {
              "id": "opt-37-4",
              "opt": "Вообще не указывать alt"
            }
          ],
          "correctAnswer": "opt-37-3",
          "explanation": "Для значимых картинок alt должен описывать содержание/смысл изображения. alt=\"image\" или отсутствие alt — плохая практика."
        },
        {
          "id": 38,
          "question": "Как корректно связать label и input?",
          "options": [
            {
              "id": "opt-38-1",
              "opt": "Через общий класс"
            },
            {
              "id": "opt-38-2",
              "opt": "Только по name"
            },
            {
              "id": "opt-38-3",
              "opt": "Через атрибут for у label и id у input"
            },
            {
              "id": "opt-38-4",
              "opt": "Это не обязательно, достаточно placeholder"
            }
          ],
          "correctAnswer": "opt-38-3",
          "explanation": "Связь label и input делается либо через for/id, либо через вложенный input внутри label. Placeholder не заменяет label."
        },
        {
          "id": 39,
          "question": "Какой атрибут используется, чтобы добавить скрытую текстовую подпись для элемента (например, иконки)?",
          "options": [
            {
              "id": "opt-39-1",
              "opt": "title"
            },
            {
              "id": "opt-39-2",
              "opt": "aria-label"
            },
            {
              "id": "opt-39-3",
              "opt": "alt"
            },
            {
              "id": "opt-39-4",
              "opt": "role"
            }
          ],
          "correctAnswer": "opt-39-2",
          "explanation": "aria-label задаёт текст, который видят скринридеры, но не видят пользователи визуально."
        },
        {
          "id": 40,
          "question": "Почему важно, чтобы интерфейс был управляем с клавиатуры?",
          "options": [
            {
              "id": "opt-40-1",
              "opt": "Это ускоряет работу разработчика"
            },
            {
              "id": "opt-40-2",
              "opt": "Иначе сайт не откроется в мобильном браузере"
            },
            {
              "id": "opt-40-3",
              "opt": "Это одно из ключевых требований доступности для людей, не использующих мышь"
            },
            {
              "id": "opt-40-4",
              "opt": "Это влияет только на SEO"
            }
          ],
          "correctAnswer": "opt-40-3",
          "explanation": "Многие пользователи используют только клавиатуру или альтернативные устройства ввода. Управляемость с клавиатуры — базовый аспект доступности."
        }
      ]
    },
    {
      "id": 9,
      "title": "CSS: Flexbox, Grid и адаптивная вёрстка",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Flexbox: оси, выравнивание и типичные паттерны",
          "CSS Grid: треки, fr-единицы и auto-fit/auto-fill",
          "Медиа-запросы и mobile-first подход",
          "Комбинирование Flexbox и Grid в реальных макетах"
        ],
        "content": "### Flexbox: одномерная раскладка\n\nFlexbox хорошо подходит для расположения элементов по **одной оси** (горизонтальной или вертикальной).\n\nОсновная схема:\n\n```css\n.container {\n  display: flex;\n}\n```\n\nВажные свойства контейнера:\n\n- `flex-direction`: направление главной оси\n  - `row` (по умолчанию)\n  - `row-reverse`\n  - `column`\n  - `column-reverse`\n\n- `justify-content`: выравнивание по **главной** оси\n  - `flex-start`, `center`, `flex-end`\n  - `space-between`, `space-around`, `space-evenly`\n\n- `align-items`: выравнивание по **перпендикулярной** оси\n  - `stretch` (по умолчанию), `flex-start`, `center`, `flex-end`, `baseline`\n\nПример горизонтального меню:\n\n```css\n.nav {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n```\n\n---\n\n### Flex элементы\n\nУ дочерних элементов:\n\n- `flex: 1` — занять доступное пространство.\n- `flex-grow`, `flex-shrink`, `flex-basis` — более точный контроль.\n\n```css\n.card {\n  flex: 1 1 200px;\n}\n```\n\n- 1 — может расти\n- 1 — может сжиматься\n- 200px — базовый размер\n\n---\n\n### CSS Grid: двумерная раскладка\n\nGrid удобен для сеток в 2D — строки и столбцы.\n\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 16px;\n}\n```\n\n- `1fr` — доля доступного пространства.\n- `repeat(3, 1fr)` — три одинаковых столбца.\n\nАдаптивная сетка с `auto-fit` и `minmax`:\n\n```css\n.grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 16px;\n}\n```\n\nЗдесь:\n- `minmax(200px, 1fr)` — элемент не меньше 200px, но может расти до 1fr.\n- `auto-fit` — автоматически подбирает количество колонок по ширине контейнера.\n\n---\n\n### Медиа-запросы и mobile-first\n\nMobile-first: сначала пишем стили для маленьких экранов, потом добавляем медиа-запросы для больших.\n\n```css\n/* базовые стили для мобильных */\n.container {\n  display: flex;\n  flex-direction: column;\n}\n\n/* от 768px и выше */\n@media (min-width: 768px) {\n  .container {\n    flex-direction: row;\n  }\n}\n```\n\nТипичные брейкпоинты (пример):\n- 480px — маленькие телефоны\n- 768px — планшеты\n- 1024px — ноутбуки\n- 1280px+ — десктопы\n\n---\n\n### Комбинирование Flexbox и Grid\n\nЧастый паттерн:\n\n- сверху layout на Grid: шапка, контент, сайдбар, подвал\n- внутри отдельных блоков — Flexbox для выравнивания элементов\n\n```css\n.layout {\n  display: grid;\n  grid-template-columns: 1fr 300px;\n  grid-template-rows: auto 1fr auto;\n  grid-template-areas:\n    \"header header\"\n    \"main sidebar\"\n    \"footer footer\";\n}\n\n.header { grid-area: header; }\n.main { grid-area: main; }\n.sidebar { grid-area: sidebar; }\n.footer { grid-area: footer; }\n\n.header-inner {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n```\n\nТаким образом, Grid отвечает за глобальную сетку, а Flex — за внутренние элементы.\n",
        "keyPoints": [
          "Flexbox — для одномерных раскладок (по одной оси), Grid — для двумерных",
          "justify-content выравнивает по главной оси, align-items — по перпендикулярной",
          "fr — доля доступного пространства в Grid",
          "auto-fit + minmax позволяют строить адаптивные сетки без жёстких брейкпоинтов",
          "Mobile-first подход: базовые стили для маленьких экранов + @media (min-width: ...)"
        ]
      },
      "practice": [
        "Сверстайте шапку сайта (логотип + навигация + кнопка) с помощью Flexbox так, чтобы элементы были выровнены по вертикали и распределены по горизонтали.",
        "Создайте адаптивную галерею карточек на Grid с использованием repeat(auto-fit, minmax(...)), чтобы количество колонок менялось в зависимости от ширины.",
        "Сделайте простой layout: header, main, sidebar, footer на CSS Grid, а внутри header расположите элементы (логотип, меню, кнопки) на Flexbox."
      ],
      "quiz": [
        {
          "id": 41,
          "question": "За что отвечает свойство justify-content в flex-контейнере?",
          "options": [
            {
              "id": "opt-41-1",
              "opt": "Выравнивание по поперечной оси"
            },
            {
              "id": "opt-41-2",
              "opt": "Выравнивание по главной оси"
            },
            {
              "id": "opt-41-3",
              "opt": "Определяет направление оси"
            },
            {
              "id": "opt-41-4",
              "opt": "Определяет перенос элементов"
            }
          ],
          "correctAnswer": "opt-41-2",
          "explanation": "justify-content управляет выравниванием элементов по главной оси flex-контейнера."
        },
        {
          "id": 42,
          "question": "Какое значение flex-direction используется по умолчанию?",
          "options": [
            {
              "id": "opt-42-1",
              "opt": "row"
            },
            {
              "id": "opt-42-2",
              "opt": "column"
            },
            {
              "id": "opt-42-3",
              "opt": "row-reverse"
            },
            {
              "id": "opt-42-4",
              "opt": "column-reverse"
            }
          ],
          "correctAnswer": "opt-42-1",
          "explanation": "По умолчанию flex-direction: row — элементы располагаются слева направо по горизонтали."
        },
        {
          "id": 43,
          "question": "Что означает единица измерения 1fr в CSS Grid?",
          "options": [
            {
              "id": "opt-43-1",
              "opt": "1 пиксель"
            },
            {
              "id": "opt-43-2",
              "opt": "1% ширины контейнера"
            },
            {
              "id": "opt-43-3",
              "opt": "Долю от свободного пространства"
            },
            {
              "id": "opt-43-4",
              "opt": "Фиксированный размер"
            }
          ],
          "correctAnswer": "opt-43-3",
          "explanation": "fr (fraction) — это доля доступного свободного пространства в контейнере."
        },
        {
          "id": 44,
          "question": "Какой синтаксис медиа-запроса соответствует подходу mobile-first?",
          "options": [
            {
              "id": "opt-44-1",
              "opt": "@media (max-width: 768px) { ... }"
            },
            {
              "id": "opt-44-2",
              "opt": "@media (min-width: 768px) { ... }"
            },
            {
              "id": "opt-44-3",
              "opt": "@media (width: 768px) { ... }"
            },
            {
              "id": "opt-44-4",
              "opt": "@media screen and (min-device-width: 768px) { ... }"
            }
          ],
          "correctAnswer": "opt-44-2",
          "explanation": "Mobile-first: базовые стили для маленьких экранов, а затем расширения через @media (min-width: ...)."
        },
        {
          "id": 45,
          "question": "Для чего часто используют сочетание auto-fit и minmax в grid-template-columns?",
          "options": [
            {
              "id": "opt-45-1",
              "opt": "Чтобы скрыть колонки"
            },
            {
              "id": "opt-45-2",
              "opt": "Чтобы сделать сетку фиксированной ширины"
            },
            {
              "id": "opt-45-3",
              "opt": "Чтобы автоматически подстраивать количество колонок под ширину контейнера"
            },
            {
              "id": "opt-45-4",
              "opt": "Чтобы отключить адаптивность"
            }
          ],
          "correctAnswer": "opt-45-3",
          "explanation": "auto-fit + minmax позволяет браузеру автоматически вычислять количество колонок, чтобы карточки красиво раскладывались по ширине."
        }
      ]
    },
    {
      "id": 10,
      "title": "CSS-архитектура и современные подходы к стилям",
      "duration": "140 мин",
      "theory": {
        "topics": [
          "BEM-методология и нейминг классов",
          "CSS Modules и локальные стили",
          "Переменные CSS (custom properties) и темы",
          "Tailwind / utility-first подход (обзорно)",
          "Организация стилей в реальном проекте"
        ],
        "content": "### Зачем нужна архитектура CSS\n\nНа небольших демо можно обойтись простыми классами, но в реальных проектах:\n- стили растут,\n- имена начинают конфликтовать,\n- сложно понимать, что за что отвечает.\n\nНужны **правила и структура**, чтобы стили были предсказуемы и масштабируемы.\n\n---\n\n### BEM (Block, Element, Modifier)\n\nПример блока карточки товара:\n\n```html\n<article class=\"product-card product-card--featured\">\n  <h2 class=\"product-card__title\">Название</h2>\n  <button class=\"product-card__button product-card__button--primary\">\n    Купить\n  </button>\n</article>\n```\n\n- Блок: `product-card`\n- Элемент: `product-card__title`, `product-card__button`\n- Модификатор: `product-card--featured`, `product-card__button--primary`\n\nПлюсы:\n- предсказуемые имена,\n- легко искать в коде,\n- меньше конфликтов стилей.\n\n---\n\n### CSS Modules\n\nCSS Modules позволяют автоматически делать классы **локальными** для компонента (часто используется в React).\n\n```css\n/* Button.module.css */\n.button {\n  padding: 8px 16px;\n  border-radius: 4px;\n}\n\n.buttonPrimary {\n  background: #2563eb;\n  color: #fff;\n}\n```\n\n```jsx\n// Button.tsx\nimport styles from './Button.module.css';\n\nexport function Button({ children }) {\n  return (\n    <button className={styles.button + ' ' + styles.buttonPrimary}>\n      {children}\n    </button>\n  );\n}\n```\n\nСгенерированный класс может выглядеть как `Button_button__1a2b3`, что исключает конфликты имён.\n\n---\n\n### Переменные CSS (custom properties) и темы\n\nОбъявление в :root:\n\n```css\n:root {\n  --color-bg: #ffffff;\n  --color-text: #111827;\n  --spacing-md: 16px;\n}\n\nbody {\n  background: var(--color-bg);\n  color: var(--color-text);\n}\n```\n\nПереключение темы:\n\n```css\n:root[data-theme='dark'] {\n  --color-bg: #020617;\n  --color-text: #e5e7eb;\n}\n```\n\nВ JS/React можно менять атрибут `data-theme` на html/body и таким образом переключать тему без переписания стилей.\n\n---\n\n### Utility-first (на примере Tailwind, обзорно)\n\nUtility-first подход: вместо написания своих классов, вы используете набор готовых utility-классов.\n\nПример (Tailwind-стиль):\n\n```html\n<button class=\"px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700\">\n  Купить\n</button>\n```\n\nПреимущества:\n- быстрое прототипирование,\n- меньше переключений между HTML и CSS.\n\nНедостатки без дисциплины:\n- \"шумные\" классы в разметке,\n- сложнее поддерживать, если нет общих паттернов.\n\n---\n\n### Организация стилей в проекте\n\nВариант для React-проекта:\n\n- глобальные стили: `src/styles/global.css` (reset, базовая типографика, переменные).\n- компоненты: `ComponentName.tsx` + `ComponentName.module.css`.\n- темы: переменные в :root, переключение темы через атрибут/класс.\n\nРекомендации:\n- избегать глобальных селекторов наподобие `div { ... }`.\n- не завязываться на структуру DOM (селекторы типа `.header .nav ul li a`).\n- использовать нейминг по BEM или похожей методологии, даже внутри CSS Modules.\n",
        "keyPoints": [
          "BEM даёт читаемый и предсказуемый нейминг классов: block__element--modifier",
          "CSS Modules изолируют стили компонента и предотвращают конфликты имён",
          "CSS-переменные удобно использовать для тем и дизайн-токенов",
          "Тема может переключаться через изменение класса/атрибута на корневом элементе",
          "Важно минимизировать глобальные стили и жёстко завязанные селекторы"
        ]
      },
      "practice": [
        "Возьмите маленький блок интерфейса (карточка, модальное окно, форма) и переименуйте его классы по BEM, переписав CSS.",
        "Создайте простой React-компонент (или аналог) с CSS Modules: отдельно файл компонента и файл стилей, используйте несколько классов и модификаторов.",
        "Реализуйте два варианта темы (light/dark) с помощью CSS-переменных и переключения атрибута data-theme на корневом элементе."
      ],
      "quiz": [
        {
          "id": 46,
          "question": "Что в BEM считается блоком?",
          "options": [
            {
              "id": "opt-46-1",
              "opt": "Любой тег div"
            },
            {
              "id": "opt-46-2",
              "opt": "Логически самостоятельный компонент интерфейса (например, карточка товара)"
            },
            {
              "id": "opt-46-3",
              "opt": "Любой элемент с классом"
            },
            {
              "id": "opt-46-4",
              "opt": "Только корневой тег body"
            }
          ],
          "correctAnswer": "opt-46-2",
          "explanation": "Блок в BEM — независимый, логически завершённый компонент интерфейса, который можно переиспользовать."
        },
        {
          "id": 47,
          "question": "Какой из классов соответствует элементу по BEM?",
          "options": [
            {
              "id": "opt-47-1",
              "opt": "card__title"
            },
            {
              "id": "opt-47-2",
              "opt": "card--large"
            },
            {
              "id": "opt-47-3",
              "opt": "card"
            },
            {
              "id": "opt-47-4",
              "opt": "large-card"
            }
          ],
          "correctAnswer": "opt-47-1",
          "explanation": "card__title — элемент блока card. card--large — модификатор блока."
        },
        {
          "id": 48,
          "question": "Какую проблему решают CSS Modules?",
          "options": [
            {
              "id": "opt-48-1",
              "opt": "Автоматически добавляют префиксы к CSS-свойствам"
            },
            {
              "id": "opt-48-2",
              "opt": "Изолируют стили компонента, предотвращая конфликты имён классов"
            },
            {
              "id": "opt-48-3",
              "opt": "Ускоряют рендер браузера"
            },
            {
              "id": "opt-48-4",
              "opt": "Заменяют JavaScript"
            }
          ],
          "correctAnswer": "opt-48-2",
          "explanation": "CSS Modules генерируют уникальные имена классов и делают стили локальными для компонента."
        },
        {
          "id": 49,
          "question": "Где обычно объявляют CSS-переменные для темы приложения?",
          "options": [
            {
              "id": "opt-49-1",
              "opt": "Внутри каждого компонента отдельно"
            },
            {
              "id": "opt-49-2",
              "opt": "В :root или на корневом элементе (html/body)"
            },
            {
              "id": "opt-49-3",
              "opt": "Только в @media-запросах"
            },
            {
              "id": "opt-49-4",
              "opt": "Только в inline-стилях"
            }
          ],
          "correctAnswer": "opt-49-2",
          "explanation": "Объявляя переменные в :root или на корневом элементе, мы делаем их доступными во всём приложении."
        },
        {
          "id": 50,
          "question": "Какой плюс у utility-first подхода (например, Tailwind) для разработки?",
          "options": [
            {
              "id": "opt-50-1",
              "opt": "Не нужно понимать CSS"
            },
            {
              "id": "opt-50-2",
              "opt": "Можно быстро прототипировать интерфейсы, описывая стили сразу в разметке"
            },
            {
              "id": "opt-50-3",
              "opt": "CSS автоматически генерируется без участия разработчика"
            },
            {
              "id": "opt-50-4",
              "opt": "Код становится всегда короче"
            }
          ],
          "correctAnswer": "opt-50-2",
          "explanation": "Utility-first даёт набор готовых классов, что ускоряет сборку интерфейса, но требует дисциплины и понимания CSS."
        }
      ]
    },
    {
      "id": 11,
      "title": "Массивы, строки, сортировки и Big O",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Базовые операции с массивами и строками",
          "Алгоритмическая сложность (Big O)",
          "Линейный и двоичный поиск",
          "Простые алгоритмы сортировки: bubble, selection, insertion",
          "Практические задачи с массивами и строками на собеседованиях"
        ],
        "content": "### Массивы в JavaScript\n\nМассив — упорядоченная коллекция элементов.\n\n```js\nconst numbers = [1, 2, 3];\n```\n\nЧасто используемые методы:\n\n- **Добавление/удаление**:\n  - `push`, `pop` — конец массива\n  - `unshift`, `shift` — начало массива\n\n```js\nconst arr = [1, 2];\narr.push(3);      // [1, 2, 3]\narr.pop();        // [1, 2]\narr.unshift(0);   // [0, 1, 2]\narr.shift();      // [1, 2]\n```\n\n- **Немутирующие методы** (важно для React):\n  - `map`, `filter`, `reduce`, `slice`, `concat`\n\n```js\nconst doubled = arr.map(x => x * 2);\nconst filtered = arr.filter(x => x > 1);\nconst sum = arr.reduce((acc, x) => acc + x, 0);\n```\n\n---\n\n### Строки\n\nСтроки ведут себя как массив символов, но **неизменяемы**.\n\n```js\nconst str = 'hello';\nstr[0];       // 'h'\nstr.toUpperCase(); // 'HELLO' (создаёт новую строку)\n```\n\nПолезные методы:\n- `includes`, `indexOf`, `startsWith`, `endsWith`\n- `slice`, `substring`, `split`, `join`\n\n```js\n'frontend'.includes('end');      // true\n'2025-11-28'.split('-');         // ['2025', '11', '28']\n['a', 'b'].join(', ');           // 'a, b'\n```\n\n---\n\n### Алгоритмическая сложность (Big O)\n\nBig O описывает, как растёт время/память алгоритма в зависимости от размера входных данных `n`.\n\nТипичные сложности:\n\n- `O(1)` — константная (доступ по индексу массива)\n- `O(n)` — линейная (один проход по массиву)\n- `O(n²)` — квадратная (вложенные циклы)\n- `O(log n)` — логарифмическая (двоичный поиск)\n- `O(n log n)` — хорошие сортировки (quick sort, merge sort в среднем)\n\nПример `O(n)`:\n\n```js\nfunction sum(arr) {\n  let s = 0;\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i];\n  }\n  return s;\n}\n```\n\n---\n\n### Линейный и двоичный поиск\n\n**Линейный поиск (O(n))**:\n\n```js\nfunction linearSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n}\n```\n\n**Двоичный поиск (O(log n))** — работает только на отсортированном массиве:\n\n```js\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n\n  return -1;\n}\n```\n\n---\n\n### Простые сортировки (интервью-классика)\n\n#### Bubble sort (пузырьковая сортировка)\n\nИдея: многократно \"пропускаем\" массив, всплывая большие элементы в конец.\n\n```js\nfunction bubbleSort(arr) {\n  const a = [...arr];\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < a.length - 1 - i; j++) {\n      if (a[j] > a[j + 1]) {\n        [a[j], a[j + 1]] = [a[j + 1], a[j]];\n      }\n    }\n  }\n  return a;\n}\n```\n\nСложность: `O(n²)`.\n\n#### Selection sort (сортировка выбором)\n\nНаходим минимум и ставим его в начало, повторяем для остатка массива.\n\n```js\nfunction selectionSort(arr) {\n  const a = [...arr];\n  for (let i = 0; i < a.length; i++) {\n    let minIndex = i;\n    for (let j = i + 1; j < a.length; j++) {\n      if (a[j] < a[minIndex]) minIndex = j;\n    }\n    [a[i], a[minIndex]] = [a[minIndex], a[i]];\n  }\n  return a;\n}\n```\n\n#### Insertion sort (вставками)\n\nСтроим отсортированную часть массива, вставляя новый элемент в нужное место.\n\n```js\nfunction insertionSort(arr) {\n  const a = [...arr];\n  for (let i = 1; i < a.length; i++) {\n    const current = a[i];\n    let j = i - 1;\n    while (j >= 0 && a[j] > current) {\n      a[j + 1] = a[j];\n      j--;\n    }\n    a[j + 1] = current;\n  }\n  return a;\n}\n```\n\nВсе три — `O(n²)` в худшем случае. В реальных проектах стоит использовать встроенный `Array.prototype.sort` с компаратором, но на собеседованиях часто просят объяснить или реализовать простую сортировку.\n\n---\n\n### Типичные задачи с массивами/строками на собеседовании\n\n- найти максимум/минимум в массиве;\n- развернуть массив или строку (`[1,2,3]` → `[3,2,1]`);\n- проверить, является ли строка палиндромом;\n- удалить дубликаты из массива;\n- найти индекс первого уникального символа в строке и т.п.",
        "keyPoints": [
          "Массивы и строки — основа большинства алгоритмических задач на фронтенд-собеседованиях",
          "Big O описывает, как алгоритм масштабируется при росте n",
          "Линейный поиск — O(n), двоичный — O(log n), но требует отсортированного массива",
          "Простые сортировки (bubble, selection, insertion) имеют сложность O(n²)",
          "В реальном коде используют встроенный sort, но на интервью важно понимать базовые алгоритмы"
        ]
      },
      "practice": [
        "Реализуйте функцию, которая принимает массив чисел и возвращает новый массив без дубликатов (можно сначала решить через двойной цикл, потом через Set).",
        "Напишите функцию isPalindrome(str), которая проверяет, является ли строка палиндромом (игнорируйте пробелы и регистр).",
        "Реализуйте три сортировки: bubbleSort, selectionSort, insertionSort и сравните их скорость на маленьких и больших массивах (через console.time)."
      ],
      "quiz": [
        {
          "id": 51,
          "question": "Какова временная сложность простого линейного поиска в массиве из n элементов?",
          "options": [
            {
              "id": "opt-51-1",
              "opt": "O(1)"
            },
            {
              "id": "opt-51-2",
              "opt": "O(log n)"
            },
            {
              "id": "opt-51-3",
              "opt": "O(n)"
            },
            {
              "id": "opt-51-4",
              "opt": "O(n²)"
            }
          ],
          "correctAnswer": "opt-51-3",
          "explanation": "В худшем случае линейный поиск проходит все элементы, поэтому сложность O(n)."
        },
        {
          "id": 52,
          "question": "Для какого типа массива корректно применять двоичный поиск?",
          "options": [
            {
              "id": "opt-52-1",
              "opt": "Для любого массива"
            },
            {
              "id": "opt-52-2",
              "opt": "Только для отсортированного массива"
            },
            {
              "id": "opt-52-3",
              "opt": "Только для массива чисел"
            },
            {
              "id": "opt-52-4",
              "opt": "Только для массива строк"
            }
          ],
          "correctAnswer": "opt-52-2",
          "explanation": "Двоичный поиск делит массив пополам, поэтому он работает только на отсортированных данных."
        },
        {
          "id": 53,
          "question": "Какая временная сложность у пузырьковой сортировки (bubble sort) в худшем случае?",
          "options": [
            {
              "id": "opt-53-1",
              "opt": "O(1)"
            },
            {
              "id": "opt-53-2",
              "opt": "O(log n)"
            },
            {
              "id": "opt-53-3",
              "opt": "O(n)"
            },
            {
              "id": "opt-53-4",
              "opt": "O(n²)"
            }
          ],
          "correctAnswer": "opt-53-4",
          "explanation": "Bubble sort использует два вложенных цикла по массиву, поэтому время растёт как n²."
        },
        {
          "id": 54,
          "question": "Что делает метод Array.prototype.filter?",
          "options": [
            {
              "id": "opt-54-1",
              "opt": "Мутирует исходный массив, удаляя элементы"
            },
            {
              "id": "opt-54-2",
              "opt": "Возвращает новый массив только с элементами, для которых колбэк вернул true"
            },
            {
              "id": "opt-54-3",
              "opt": "Сортирует массив по условию"
            },
            {
              "id": "opt-54-4",
              "opt": "Преобразует каждый элемент по колбэку"
            }
          ],
          "correctAnswer": "opt-54-2",
          "explanation": "filter не мутирует исходный массив, а возвращает новый, отфильтрованный по предикату."
        },
        {
          "id": 55,
          "question": "Какое утверждение про строки в JavaScript верно?",
          "options": [
            {
              "id": "opt-55-1",
              "opt": "Строки изменяемы, можно менять отдельные символы по индексу"
            },
            {
              "id": "opt-55-2",
              "opt": "Строки неизменяемы, любые операции создают новую строку"
            },
            {
              "id": "opt-55-3",
              "opt": "Строки — это приватный тип данных, к ним нельзя применять методы"
            },
            {
              "id": "opt-55-4",
              "opt": "Строки существуют только в строгом режиме"
            }
          ],
          "correctAnswer": "opt-55-2",
          "explanation": "Строки в JS иммутабельны: str[0] = 'H' не сработает, методы возвращают новые строки."
        }
      ]
    },
    {
      "id": 12,
      "title": "Стек, очередь, рекурсия и основы BFS/DFS",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Структуры данных: стек и очередь",
          "Связь стека с вызовами функций и рекурсией",
          "Рекурсия: базовый случай и шаг рекурсии",
          "Обход структур данных: идеи BFS и DFS",
          "Решение типичных задач LeetCode-stye для фронта"
        ],
        "content": "### Стек (Stack)\n\n**Стек** — структура данных по принципу *LIFO* (Last In — First Out).\n\nОперации:\n- `push` — положить элемент на вершину стека\n- `pop` — снять элемент с вершины\n- `peek` (или top) — посмотреть верхний элемент\n\nПример реализации стека на массиве:\n\n```js\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(value) {\n    this.items.push(value);\n  }\n\n  pop() {\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n```\n\nВ JS стек тесно связан с **call stack** — стек вызовов функций.\n\n---\n\n### Очередь (Queue)\n\n**Очередь** — структура *FIFO* (First In — First Out).\n\nОперации:\n- `enqueue` — добавить в конец очереди\n- `dequeue` — удалить из начала\n\nПростая реализация на массиве:\n\n```js\nclass Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(value) {\n    this.items.push(value);\n  }\n\n  dequeue() {\n    return this.items.shift();\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n```\n\nОчередь часто используется в алгоритмах обхода в ширину (BFS).\n\n---\n\n### Рекурсия\n\n**Рекурсия** — когда функция вызывает сама себя с изменёнными аргументами.\n\nВажные элементы рекурсивной функции:\n\n1. **Базовый случай** — условие остановки (иначе будет бесконечный вызов).\n2. **Рекурсивный шаг** — упрощение задачи и рекурсивный вызов.\n\nПример: факториал\n\n```js\nfunction factorial(n) {\n  if (n <= 1) return 1;        // базовый случай\n  return n * factorial(n - 1); // рекурсивный шаг\n}\n```\n\nПример: сумма массива\n\n```js\nfunction sum(arr, index = 0) {\n  if (index === arr.length) return 0;            // базовый случай\n  return arr[index] + sum(arr, index + 1);       // рекурсивный шаг\n}\n```\n\nВажно: каждая рекурсия использует **call stack**, слишком глубокая рекурсия может привести к \"Maximum call stack size exceeded\".\n\n---\n\n### DFS и стек\n\n**DFS (Depth-First Search)** — поиск в глубину. Идея: идём как можно глубже, потом откатываемся.\n\nВ дереве это выглядит как рекурсивный обход:\n\n```js\nfunction dfs(node) {\n  if (!node) return;\n\n  // посещаем текущий узел\n  console.log(node.value);\n\n  // рекурсивно обходим детей\n  for (const child of node.children) {\n    dfs(child);\n  }\n}\n```\n\nРекурсивный DFS по сути использует **стек вызовов**.\n\nИтеративный DFS можно реализовать с помощью явного стека:\n\n```js\nfunction dfsIterative(root) {\n  const stack = [];\n  if (root) stack.push(root);\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n    console.log(node.value);\n\n    // кладём детей в стек (обычно в обратном порядке, если нужен тот же порядок обхода)\n    for (let i = node.children.length - 1; i >= 0; i--) {\n      stack.push(node.children[i]);\n    }\n  }\n}\n```\n\n---\n\n### BFS и очередь\n\n**BFS (Breadth-First Search)** — поиск в ширину. Идея: сначала обход соседей текущего уровня, потом переход к следующему.\n\n```js\nfunction bfs(root) {\n  const queue = [];\n  if (root) queue.push(root);\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n    console.log(node.value);\n\n    for (const child of node.children) {\n      queue.push(child);\n    }\n  }\n}\n```\n\nBFS часто используют для задач:\n- найти кратчайший путь (по количеству шагов),\n- обойти уровень за уровнем (например, для UI-деревьев или DOM-дерева).\n\n---\n\n### Типичные задачки\n\n- Проверка корректности скобочной последовательности (используется стек).\n- Разворот строки или списка через стек/рекурсию.\n- Обход вложенных структур (меню, дерево комментариев и т.п.).\n\nПример проверки скобок:\n\n```js\nfunction isValidBrackets(str) {\n  const stack = [];\n  const pairs = {\n    ')': '(',\n    ']': '[',\n    '}': '{'\n  };\n\n  for (const ch of str) {\n    if (ch === '(' || ch === '[' || ch === '{') {\n      stack.push(ch);\n    } else if (ch === ')' || ch === ']' || ch === '}') {\n      const last = stack.pop();\n      if (last !== pairs[ch]) return false;\n    }\n  }\n\n  return stack.length === 0;\n}\n```",
        "keyPoints": [
          "Стек работает по принципу LIFO, очередь — FIFO",
          "Call stack в JS — это стек вызовов функций, на котором строится рекурсия",
          "Любая рекурсивная функция должна иметь базовый случай и шаг рекурсии",
          "DFS естественно реализуется через рекурсию или явный стек",
          "BFS реализуется через очередь и полезен для обхода по уровням и поиска кратчайшего пути"
        ]
      },
      "practice": [
        "Реализуйте класс Stack и класс Queue на массивах, добавьте методы isEmpty и size.",
        "Решите задачу проверки корректности скобочной последовательности (), [], {} с помощью стека.",
        "Реализуйте рекурсивную функцию, которая разворачивает строку (\"abc\" → \"cba\"), и сравните её с итеративной реализацией."
      ],
      "quiz": [
        {
          "id": 56,
          "question": "Какой принцип работы у структуры данных \"стек\"?",
          "options": [
            {
              "id": "opt-56-1",
              "opt": "FIFO (First In — First Out)"
            },
            {
              "id": "opt-56-2",
              "opt": "LIFO (Last In — First Out)"
            },
            {
              "id": "opt-56-3",
              "opt": "Случайный доступ"
            },
            {
              "id": "opt-56-4",
              "opt": "Кольцевая очередь"
            }
          ],
          "correctAnswer": "opt-56-2",
          "explanation": "Стек — это LIFO: последним добавили, первым забрали."
        },
        {
          "id": 57,
          "question": "Что из перечисленного является базовым случаем в рекурсивной функции?",
          "options": [
            {
              "id": "opt-57-1",
              "opt": "Условие, при котором функция вызывает себя ещё раз"
            },
            {
              "id": "opt-57-2",
              "opt": "Условие, при котором функция прекращает вызывать себя и возвращает результат"
            },
            {
              "id": "opt-57-3",
              "opt": "Всегда первое условие в функции"
            },
            {
              "id": "opt-57-4",
              "opt": "Вызов setTimeout внутри функции"
            }
          ],
          "correctAnswer": "opt-57-2",
          "explanation": "Базовый случай останавливает рекурсию. Без него будет бесконечный вызов функций."
        },
        {
          "id": 58,
          "question": "Какой структурой данных удобнее всего реализовать BFS (обход в ширину)?",
          "options": [
            {
              "id": "opt-58-1",
              "opt": "Стек"
            },
            {
              "id": "opt-58-2",
              "opt": "Очередь"
            },
            {
              "id": "opt-58-3",
              "opt": "Массив без ограничений"
            },
            {
              "id": "opt-58-4",
              "opt": "Объект"
            }
          ],
          "correctAnswer": "opt-58-2",
          "explanation": "При BFS элементы обрабатываются в порядке поступления — это поведение очереди (FIFO)."
        },
        {
          "id": 59,
          "question": "Для чего часто используют стек в задачах со строками на собеседовании?",
          "options": [
            {
              "id": "opt-59-1",
              "opt": "Для сортировки символов строки"
            },
            {
              "id": "opt-59-2",
              "opt": "Для проверки корректности скобочной последовательности"
            },
            {
              "id": "opt-59-3",
              "opt": "Для подсчёта длины строки"
            },
            {
              "id": "opt-59-4",
              "opt": "Для поиска подстроки"
            }
          ],
          "correctAnswer": "opt-59-2",
          "explanation": "Задача на проверку скобок — классический пример использования стека: открывающие скобки кладём, закрывающие — сверяем."
        },
        {
          "id": 60,
          "question": "Почему слишком глубокая рекурсия в JS может привести к ошибке \"Maximum call stack size exceeded\"?",
          "options": [
            {
              "id": "opt-60-1",
              "opt": "Потому что рекурсия автоматически создаёт бесконечный цикл"
            },
            {
              "id": "opt-60-2",
              "opt": "Потому что каждый рекурсивный вызов занимает место в call stack, который ограничен по размеру"
            },
            {
              "id": "opt-60-3",
              "opt": "Потому что JS не поддерживает рекурсию"
            },
            {
              "id": "opt-60-4",
              "opt": "Потому что рекурсия запрещена в strict mode"
            }
          ],
          "correctAnswer": "opt-60-2",
          "explanation": "Call stack имеет ограниченный размер; если рекурсия слишком глубокая или бесконечная, стек переполняется."
        }
      ]
    },
    {
      "id": 13,
      "title": "TypeScript: базовые типы, объекты, интерфейсы и union/intersection",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Зачем нужен TypeScript фронтенд-разработчику",
          "Базовые типы: number, string, boolean, null, undefined, any, unknown, never",
          "Типизация объектов и массивов",
          "Интерфейсы и type-алиасы",
          "Union и intersection типы"
        ],
        "content": "### Зачем TypeScript фронтендеру\n\nTypeScript добавляет **статическую типизацию** поверх JavaScript:\n\n- раньше ловит ошибки (на этапе компиляции);\n- улучшает автодополнение и навигацию по коду;\n- облегчает рефакторинг;\n- делает код более самодокументирующим.\n\nTS **не заменяет** JS, а компилируется в обычный JavaScript.\n\n---\n\n### Базовые типы\n\n```ts\nlet count: number = 0;\nlet title: string = 'Hello';\nlet isActive: boolean = true;\n\nlet nothing: null = null;\nlet notDefined: undefined = undefined;\n\nlet anything: any = 42;          // по возможности избегать\nlet unknownValue: unknown;       // более безопасный аналог any\n\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n```\n\n- `any` отключает проверку типов — с ним стоит быть осторожнее.\n- `unknown` требует проверки типа перед использованием.\n- `never` — функции, которые **никогда** не завершаются нормально (бросают ошибку или бесконечный цикл).\n\n---\n\n### Типизация объектов и массивов\n\n```ts\nconst user: { name: string; age: number } = {\n  name: 'Anna',\n  age: 30\n};\n\nconst numbers: number[] = [1, 2, 3];\nconst names: Array<string> = ['Anna', 'Julia'];\n\n// кортеж (tuple)\nconst point: [number, number] = [10, 20];\n```\n\n---\n\n### Интерфейсы и type-алиасы\n\n**Интерфейс** описывает форму объекта:\n\n```ts\ninterface User {\n  id: number;\n  name: string;\n  email?: string; // необязательное поле\n}\n\nconst u1: User = {\n  id: 1,\n  name: 'Anna'\n};\n```\n\n`email?` — необязательное свойство.\n\n**Type-алиас**:\n\n```ts\ntype UserId = number | string;\n\ntype UserProfile = {\n  id: UserId;\n  name: string;\n};\n```\n\nИнтерфейс и type часто взаимозаменяемы для объектов. Часто используют такую практику:\n\n- `interface` — для описания \"формы\" сущностей (модели, DTO);\n- `type` — для объединений (union), маппингов, сложных составных типов.\n\n---\n\n### Union типы\n\n**Union** — значение может быть одного из перечисленных типов.\n\n```ts\ntype Status = 'idle' | 'loading' | 'success' | 'error';\n\nlet status: Status = 'idle';\nstatus = 'loading';\n// status = 'unknown'; // ошибка компиляции\n```\n\nUnion часто используют для:\n\n- статусов состояний;\n- действий в Redux-подобных системах;\n- параметров, где допустимы несколько типов.\n\n---\n\n### Intersection типы\n\n**Intersection** объединяет несколько типов в один (логическое И).\n\n```ts\ninterface WithTimestamps {\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ninterface UserBase {\n  id: number;\n  name: string;\n}\n\ntype UserWithTimestamps = UserBase & WithTimestamps;\n\nconst userFull: UserWithTimestamps = {\n  id: 1,\n  name: 'Anna',\n  createdAt: new Date(),\n  updatedAt: new Date()\n};\n```\n\nIntersection удобно использовать для композиции типов (особенно в React: пропсы компонента + общие пропсы).",
        "keyPoints": [
          "TypeScript добавляет статическую типизацию, но компилируется в обычный JS",
          "any стоит использовать только в крайнем случае, unknown — более безопасная альтернатива",
          "Интерфейсы и type-алиасы помогают описывать форму объектов и связей между типами",
          "Union-тип описывает значение, которое может быть одним из нескольких вариантов",
          "Intersection-тип позволяет объединять несколько типов в один (композиция)"
        ]
      },
      "practice": [
        "Опишите интерфейс User с полями id, name, email?, role ('admin' | 'user' | 'guest'), и создайте несколько объектов этого типа.",
        "Создайте type-алиас ApiResponse<T> с полями data?: T, error?: string и используйте его для описания ответа от API пользователей (User[]).",
        "Опишите тип ComponentProps как пересечение базовых пропсов (id, className?) и специфичных пропсов (например, label, onClick), и создайте переменную с этим типом."
      ],
      "quiz": [
        {
          "id": 61,
          "question": "Какой тип в TypeScript считается наиболее \"опасным\" и отключает проверки типов?",
          "options": [
            {
              "id": "opt-61-1",
              "opt": "unknown"
            },
            {
              "id": "opt-61-2",
              "opt": "any"
            },
            {
              "id": "opt-61-3",
              "opt": "never"
            },
            {
              "id": "opt-61-4",
              "opt": "void"
            }
          ],
          "correctAnswer": "opt-61-2",
          "explanation": "Тип any отключает большинство проверок TypeScript — с ним можно делать почти всё, поэтому его использование надо минимизировать."
        },
        {
          "id": 62,
          "question": "Как объявить массив чисел в TypeScript?",
          "options": [
            {
              "id": "opt-62-1",
              "opt": "let arr: number[] = [1, 2, 3];"
            },
            {
              "id": "opt-62-2",
              "opt": "let arr: Array = [1, 2, 3];"
            },
            {
              "id": "opt-62-3",
              "opt": "let arr: numbers = [1, 2, 3];"
            },
            {
              "id": "opt-62-4",
              "opt": "let arr = [1, 2, 3] as array;"
            }
          ],
          "correctAnswer": "opt-62-1",
          "explanation": "Массив чисел задаётся как number[] или Array<number>. В примере указан правильный синтаксис."
        },
        {
          "id": 63,
          "question": "Как выглядит union-тип из строк 'idle', 'loading' и 'success'?",
          "options": [
            {
              "id": "opt-63-1",
              "opt": "type Status = 'idle', 'loading', 'success';"
            },
            {
              "id": "opt-63-2",
              "opt": "type Status = ['idle' | 'loading' | 'success'];"
            },
            {
              "id": "opt-63-3",
              "opt": "type Status = 'idle' | 'loading' | 'success';"
            },
            {
              "id": "opt-63-4",
              "opt": "type Status = ('idle', 'loading', 'success');"
            }
          ],
          "correctAnswer": "opt-63-3",
          "explanation": "Union-тип задаётся через вертикальную черту: 'idle' | 'loading' | 'success'."
        },
        {
          "id": 64,
          "question": "Чем intersection-тип A & B принципиально отличается от union-типа A | B?",
          "options": [
            {
              "id": "opt-64-1",
              "opt": "A & B означает, что значение соответствует и A, и B одновременно"
            },
            {
              "id": "opt-64-2",
              "opt": "A & B и A | B полностью эквивалентны"
            },
            {
              "id": "opt-64-3",
              "opt": "A & B означает, что значение может быть либо A, либо B"
            },
            {
              "id": "opt-64-4",
              "opt": "Intersection-типы существуют только для чисел"
            }
          ],
          "correctAnswer": "opt-64-1",
          "explanation": "Intersection (A & B) объединяет требования обоих типов: значение должно удовлетворять и A, и B."
        },
        {
          "id": 65,
          "question": "Как сделать свойство email в интерфейсе User необязательным?",
          "options": [
            {
              "id": "opt-65-1",
              "opt": "interface User { email: string | undefined }"
            },
            {
              "id": "opt-65-2",
              "opt": "interface User { email?: string }"
            },
            {
              "id": "opt-65-3",
              "opt": "interface User { optional email: string }"
            },
            {
              "id": "opt-65-4",
              "opt": "interface User { email: string? }"
            }
          ],
          "correctAnswer": "opt-65-2",
          "explanation": "В TypeScript необязательное свойство помечается знаком вопроса после имени: email?."
        }
      ]
    },
    {
      "id": 14,
      "title": "Generics и Utility Types в TypeScript",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Зачем нужны дженерики (generics)",
          "Обобщённые функции и интерфейсы",
          "Ограничения (constraints) generics",
          "Встроенные Utility Types: Partial, Required, Readonly, Pick, Omit, Record",
          "Discriminated unions (кратко)"
        ],
        "content": "### Зачем нужны generics\n\nGenerics позволяют писать **обобщённый код**, который работает с разными типами, но при этом сохраняет типобезопасность.\n\nПример без дженериков:\n\n```ts\nfunction identity(value: any): any {\n  return value;\n}\n\nconst a = identity('hello'); // тип any — потеряли информацию\n```\n\nС дженериком:\n\n```ts\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconst s = identity<string>('hello'); // T = string\nconst n = identity(10);              // T = number (TS сам выводит)\n```\n\n---\n\n### Обобщённые функции и интерфейсы\n\n```ts\nfunction wrapInArray<T>(value: T): T[] {\n  return [value];\n}\n\nconst arr1 = wrapInArray('test'); // string[]\nconst arr2 = wrapInArray(42);     // number[]\n```\n\nОбобщённый интерфейс:\n\n```ts\ninterface ApiResponse<T> {\n  data: T | null;\n  error: string | null;\n}\n\ntype User = { id: number; name: string };\n\nconst userResponse: ApiResponse<User> = {\n  data: { id: 1, name: 'Anna' },\n  error: null\n};\n```\n\n---\n\n### Ограничения (constraints)\n\nИногда нужно ограничить тип T, чтобы он имел определённые свойства.\n\n```ts\ninterface HasId {\n  id: number | string;\n}\n\nfunction getId<T extends HasId>(entity: T): T['id'] {\n  return entity.id;\n}\n\ngetId({ id: 1, name: 'Anna' });      // ок\ngetId({ name: 'Anna' });             // ошибка: нет id\n```\n\n---\n\n### Utility Types\n\nВстроенные утилиты помогают трансформировать типы.\n\n#### Partial\n\nДелает все свойства необязательными.\n\n```ts\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype UserUpdate = Partial<User>;\n\n// можно передать только часть полей\nfunction updateUser(id: number, patch: UserUpdate) {\n  // ...\n}\n```\n\n#### Required\n\nОбратное Partial — делает все свойства обязательными.\n\n```ts\ntype StrictUser = Required<User>;\n```\n\n#### Readonly\n\nДелает свойства только для чтения.\n\n```ts\ntype ReadonlyUser = Readonly<User>;\n```\n\n#### Pick и Omit\n\n```ts\ntype UserPreview = Pick<User, 'id' | 'name'>;\n\ntype UserWithoutEmail = Omit<User, 'email'>;\n```\n\n#### Record\n\nСоздаёт тип объекта с ключами одного типа и значениями другого.\n\n```ts\ntype UserMap = Record<number, User>;\n\nconst usersById: UserMap = {\n  1: { id: 1, name: 'Anna', email: 'a@example.com' }\n};\n```\n\n---\n\n### Discriminated unions (дискриминирующие объединения)\n\nИспользуются для описания \"состояний\" или \"вариантов\" сущностей.\n\n```ts\ntype LoadingState = {\n  status: 'loading';\n};\n\ntype SuccessState<T> = {\n  status: 'success';\n  data: T;\n};\n\ntype ErrorState = {\n  status: 'error';\n  error: string;\n};\n\ntype RequestState<T> = LoadingState | SuccessState<T> | ErrorState;\n\nfunction handleState<T>(state: RequestState<T>) {\n  switch (state.status) {\n    case 'loading':\n      // ...\n      break;\n    case 'success':\n      // TS знает, что здесь есть state.data\n      break;\n    case 'error':\n      // здесь есть state.error\n      break;\n  }\n}\n```\n\nКлючевой момент: общее поле `status` с разными литеральными значениями помогает TS сужать тип внутри `switch`.",
        "keyPoints": [
          "Generics позволяют писать обобщённый код без потери информации о типах",
          "Тип-параметр <T> может выводиться автоматически или задаваться явно",
          "Ограничения (extends) позволяют требовать от T наличия определённых свойств",
          "Utility Types упрощают работу с моделями (Partial, Pick, Omit и др.)",
          "Discriminated unions удобны для описания состояний и ветвления логики"
        ]
      },
      "practice": [
        "Создайте обобщённый интерфейс ApiResponse<T> и используйте его для описания ответов /users и /orders.",
        "Напишите функцию selectKeys<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>, которая возвращает объект только с указанными ключами.",
        "Опишите RequestState<T> как discriminated union со статусами 'idle' | 'loading' | 'success' | 'error' и реализуйте функцию, которая логирует сообщение в зависимости от статуса."
      ],
      "quiz": [
        {
          "id": 66,
          "question": "Что означает буква T в объявлении функции function identity<T>(value: T): T?",
          "options": [
            {
              "id": "opt-66-1",
              "opt": "Всегда означает тип string"
            },
            {
              "id": "opt-66-2",
              "opt": "Это имя параметра типа, его можно назвать как угодно"
            },
            {
              "id": "opt-66-3",
              "opt": "Зарезервированное ключевое слово TypeScript"
            },
            {
              "id": "opt-66-4",
              "opt": "Специальный тип, встроенный в TS"
            }
          ],
          "correctAnswer": "opt-66-2",
          "explanation": "T — просто соглашение по названию параметра типа, его можно назвать U, ValueType и т.п."
        },
        {
          "id": 67,
          "question": "Какой utility type делает все свойства интерфейса User необязательными?",
          "options": [
            {
              "id": "opt-67-1",
              "opt": "Readonly<User>"
            },
            {
              "id": "opt-67-2",
              "opt": "Partial<User>"
            },
            {
              "id": "opt-67-3",
              "opt": "Required<User>"
            },
            {
              "id": "opt-67-4",
              "opt": "Pick<User>"
            }
          ],
          "correctAnswer": "opt-67-2",
          "explanation": "Partial<T> делает все свойства типа T необязательными."
        },
        {
          "id": 68,
          "question": "Что делает тип Record<K, T>?",
          "options": [
            {
              "id": "opt-68-1",
              "opt": "Создаёт массив элементов типа T"
            },
            {
              "id": "opt-68-2",
              "opt": "Создаёт объект с ключами типа K и значениями типа T"
            },
            {
              "id": "opt-68-3",
              "opt": "Делает все свойства типа T только для чтения"
            },
            {
              "id": "opt-68-4",
              "opt": "Объединяет два типа в один"
            }
          ],
          "correctAnswer": "opt-68-2",
          "explanation": "Record<K, T> описывает объект: ключи типа K, значения типа T."
        },
        {
          "id": 69,
          "question": "Как ограничить дженерик T так, чтобы он всегда имел свойство id?",
          "options": [
            {
              "id": "opt-69-1",
              "opt": "function fn<T>(arg: T & { id: string }): void"
            },
            {
              "id": "opt-69-2",
              "opt": "function fn<T extends { id: string }>(arg: T): void"
            },
            {
              "id": "opt-69-3",
              "opt": "function fn<T implements { id: string }>(arg: T): void"
            },
            {
              "id": "opt-69-4",
              "opt": "Никак, generics нельзя ограничивать"
            }
          ],
          "correctAnswer": "opt-69-2",
          "explanation": "Ограничения задаются через extends: T extends { id: string }."
        },
        {
          "id": 70,
          "question": "Что является ключевым признаком discriminated union?",
          "options": [
            {
              "id": "opt-70-1",
              "opt": "Использование только числовых типов"
            },
            {
              "id": "opt-70-2",
              "opt": "Общее поле с литеральным типом, по которому можно различать варианты"
            },
            {
              "id": "opt-70-3",
              "opt": "Наличие только одного типа в объединении"
            },
            {
              "id": "opt-70-4",
              "opt": "Использование ключевого слова union"
            }
          ],
          "correctAnswer": "opt-70-2",
          "explanation": "Discriminated union имеет общее поле (например, status) с разными литеральными значениями, по которому TS сужает тип."
        }
      ]
    },
    {
      "id": 15,
      "title": "TypeScript в React-проектах: пропсы, состояние, контекст",
      "duration": "170 мин",
      "theory": {
        "topics": [
          "Типизация пропсов функциональных компонентов",
          "Типизация состояния и обработчиков событий",
          "Типизация кастомных хуков",
          "Типизация контекста (Context API)",
          "Подходы к типизации API-слоя и форм"
        ],
        "content": "### Типизация пропсов функциональных компонентов\n\nБазовый пример:\n\n```tsx\ntype ButtonProps = {\n  label: string;\n  onClick?: () => void;\n  disabled?: boolean;\n};\n\nexport function Button({ label, onClick, disabled = false }: ButtonProps) {\n  return (\n    <button onClick={onClick} disabled={disabled}>\n      {label}\n    </button>\n  );\n}\n```\n\nМожно использовать `React.FC`, но многие команды предпочитают **не** использовать его (ради более явного описания пропсов и children).\n\n```tsx\nimport type { ReactNode } from 'react';\n\ntype CardProps = {\n  title: string;\n  children: ReactNode;\n};\n\nexport function Card({ title, children }: CardProps) {\n  return (\n    <section>\n      <h2>{title}</h2>\n      {children}\n    </section>\n  );\n}\n```\n\n---\n\n### Типизация состояния и обработчиков\n\n```tsx\nimport { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState<number>(0);\n\n  const handleClick = () => {\n    setCount(prev => prev + 1);\n  };\n\n  return <button onClick={handleClick}>{count}</button>;\n}\n```\n\nЧасто тип можно вывести автоматически, но для сложных состояний полезно явно задать тип:\n\n```tsx\ntype Status = 'idle' | 'loading' | 'success' | 'error';\n\nconst [status, setStatus] = useState<Status>('idle');\n```\n\nОбработчики событий:\n\n```tsx\nconst handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n  console.log(event.target.value);\n};\n\nconst handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n  event.preventDefault();\n};\n```\n\n---\n\n### Типизация кастомных хуков\n\n```tsx\nimport { useEffect, useState } from 'react';\n\ninterface UseFetchResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n}\n\nexport function useFetch<T>(url: string): UseFetchResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    let isCancelled = false;\n\n    async function load() {\n      setLoading(true);\n      setError(null);\n      try {\n        const res = await fetch(url);\n        if (!res.ok) {\n          throw new Error('Request failed: ' + res.status);\n        }\n        const json = (await res.json()) as T;\n        if (!isCancelled) setData(json);\n      } catch (e) {\n        if (!isCancelled) setError((e as Error).message);\n      } finally {\n        if (!isCancelled) setLoading(false);\n      }\n    }\n\n    load();\n\n    return () => {\n      isCancelled = true;\n    };\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\nЗдесь generics позволяет переиспользовать хук для разных типов данных.\n\n---\n\n### Типизация контекста (Context API)\n\nШаблон для контекста:\n\n```tsx\nimport { createContext, useContext, useState, ReactNode } from 'react';\n\ninterface AuthContextValue {\n  user: string | null;\n  login: (name: string) => void;\n  logout: () => void;\n}\n\nconst AuthContext = createContext<AuthContextValue | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<string | null>(null);\n\n  const login = (name: string) => setUser(name);\n  const logout = () => setUser(null);\n\n  return (\n    <AuthContext.Provider value={{ user, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth(): AuthContextValue {\n  const ctx = useContext(AuthContext);\n  if (!ctx) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return ctx;\n}\n```\n\nЗдесь важно:\n- контекст может быть `undefined` до обёртки провайдером;\n- хук `useAuth` гарантирует, что дальше вы работаете уже с типом `AuthContextValue`.\n\n---\n\n### Типизация API-слоя и форм (в общих чертах)\n\nМодели данных для API:\n\n```ts\nexport interface UserDto {\n  id: number;\n  name: string;\n  email: string;\n}\n\nexport interface CreateUserPayload {\n  name: string;\n  email: string;\n}\n```\n\nФорма:\n\n```ts\ninterface UserFormValues {\n  name: string;\n  email: string;\n}\n```\n\nЧасто полезно отделять:\n- DTO (данные с сервера),\n- внутренние доменные типы,\n- типы для формы (могут немного отличаться).",
        "keyPoints": [
          "Пропсы компонентов удобно описывать через отдельные типы/интерфейсы",
          "useState можно параметризовать типом, особенно для сложных состояний",
          "Обработчики событий в React имеют свои типы (ChangeEvent, FormEvent и др.)",
          "Кастомные хуки с generics позволяют переиспользовать логику с разными типами данных",
          "Контекст с типизацией через createContext и собственный useXxx-хук делает работу с данными безопасной"
        ]
      },
      "practice": [
        "Создайте типизированный компонент Input с пропсами value: string, onChange: (value: string) => void, label?: string и используйте его в форме.",
        "Реализуйте простой кастомный хук useToggle(initial?: boolean), который возвращает [value, toggle], и типизируйте его.",
        "Создайте контекст ThemeContext с типом { theme: 'light' | 'dark'; toggleTheme: () => void }, провайдер и хук useTheme, затем используйте его в паре компонентов."
      ],
      "quiz": [
        {
          "id": 71,
          "question": "Как корректно типизировать пропсы компонента Button с пропсами label: string и onClick?: () => void?",
          "options": [
            {
              "id": "opt-71-1",
              "opt": "function Button(props: any) { ... }"
            },
            {
              "id": "opt-71-2",
              "opt": "type Props = { label: string; onClick?: () => void }; function Button(props: Props) { ... }"
            },
            {
              "id": "opt-71-3",
              "opt": "function Button(label: string, onClick: () => void) { ... }"
            },
            {
              "id": "opt-71-4",
              "opt": "function Button(props: { any }) { ... }"
            }
          ],
          "correctAnswer": "opt-71-2",
          "explanation": "Выделение отдельного типа Prop даёт явную и безопасную типизацию пропсов."
        },
        {
          "id": 72,
          "question": "Какой тип события использовать для обработчика изменения input в React?",
          "options": [
            {
              "id": "opt-72-1",
              "opt": "Event"
            },
            {
              "id": "opt-72-2",
              "opt": "MouseEvent<HTMLInputElement>"
            },
            {
              "id": "opt-72-3",
              "opt": "React.ChangeEvent<HTMLInputElement>"
            },
            {
              "id": "opt-72-4",
              "opt": "KeyboardEvent"
            }
          ],
          "correctAnswer": "opt-72-3",
          "explanation": "Для onChange у input используется React.ChangeEvent<HTMLInputElement>."
        },
        {
          "id": 73,
          "question": "Что верно про useState в TypeScript?",
          "options": [
            {
              "id": "opt-73-1",
              "opt": "Нельзя указывать тип, он всегда выводится автоматически"
            },
            {
              "id": "opt-73-2",
              "opt": "Тип всегда должен быть any"
            },
            {
              "id": "opt-73-3",
              "opt": "Можно указать параметр типа, например useState<number>(0)"
            },
            {
              "id": "opt-73-4",
              "opt": "useState не работает с union-типами"
            }
          ],
          "correctAnswer": "opt-73-3",
          "explanation": "useState — обобщённый хук, можно передать тип: useState<T>(initialValue)."
        },
        {
          "id": 74,
          "question": "Почему в createContext часто используют тип вида ContextType | undefined?",
          "options": [
            {
              "id": "opt-74-1",
              "opt": "Иначе TS не скомпилируется"
            },
            {
              "id": "opt-74-2",
              "opt": "Контекст может быть не инициализирован, если компонент не обёрнут в провайдер"
            },
            {
              "id": "opt-74-3",
              "opt": "Так проще работать с any"
            },
            {
              "id": "opt-74-4",
              "opt": "Это требование React 18"
            }
          ],
          "correctAnswer": "opt-74-2",
          "explanation": "До обёртки провайдером контекст может быть undefined, поэтому тип отражает эту возможность."
        },
        {
          "id": 75,
          "question": "Зачем создавать отдельный хук (например, useAuth) поверх useContext?",
          "options": [
            {
              "id": "opt-75-1",
              "opt": "Чтобы полностью скрыть React из проекта"
            },
            {
              "id": "opt-75-2",
              "opt": "Чтобы каждый компонент сам создавал свой контекст"
            },
            {
              "id": "opt-75-3",
              "opt": "Чтобы инкапсулировать проверку на undefined и вернуть гарантированно типизированное значение"
            },
            {
              "id": "opt-75-4",
              "opt": "Это просто стилистическое требование, не дающее преимуществ"
            }
          ],
          "correctAnswer": "opt-75-3",
          "explanation": "useAuth позволяет один раз проверить, что контекст не undefined, и дальше работать с безопасным типом AuthContextValue."
        }
      ]
    },
    {
      "id": 16,
      "title": "React: рендеринг, JSX, компоненты, списки и ключи",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Как работает рендеринг в React",
          "JSX и отличия от HTML",
          "Функциональные компоненты и пропсы",
          "Рендер списков и ключи",
          "Контролируемые и неконтролируемые компоненты (кратко)"
        ],
        "content": "### Ментальная модель React\n\nReact — это библиотека для построения **UI как функции от состояния**.\n\nУпрощённо:\n\n```tsx\nUI = f(state)\n```\n\nВы описываете, **как должен выглядеть интерфейс** для текущего состояния, а React сам обновляет DOM при изменениях.\n\n---\n\n### JSX\n\nJSX — это синтаксический сахар над `React.createElement`.\n\n```tsx\nconst element = <h1>Hello, React</h1>;\n```\n\nПосле компиляции превращается во что-то вроде:\n\n```js\nconst element = React.createElement('h1', null, 'Hello, React');\n```\n\nОтличия от HTML:\n\n- `class` → `className`\n- `for` → `htmlFor`\n- все атрибуты в `camelCase` (`onClick`, `tabIndex`)\n- выражения внутри `{}`:\n\n```tsx\nconst name = 'Anna';\nconst element = <h1>Hello, {name}</h1>;\n```\n\n---\n\n### Функциональные компоненты\n\nКомпонент — это функция, которая принимает **пропсы** и возвращает JSX.\n\n```tsx\ntype HelloProps = {\n  name: string;\n};\n\nfunction Hello({ name }: HelloProps) {\n  return <h1>Hello, {name}</h1>;\n}\n```\n\n- имя компонента должно начинаться с **заглавной буквы**;\n- пропсы передаются, как атрибуты:\n\n```tsx\n<Hello name=\"Anna\" />\n```\n\n---\n\n### Списки и ключи\n\nРендер списка:\n\n```tsx\nconst users = [\n  { id: 1, name: 'Anna' },\n  { id: 2, name: 'Julia' }\n];\n\nfunction UserList() {\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\nЗачем нужен `key`?\n\n- помогает React отслеживать элементы между рендерами;\n- оптимизирует обновление DOM;\n- снижает вероятность багов при вставке/удалении элементов.\n\n**Плохой ключ** — индекс массива:\n\n```tsx\nitems.map((item, index) => <li key={index}>{item}</li>);\n```\n\nИспользовать индекс допустимо только если:\n- список статичен,\n- элементы не переупорядочиваются,\n- нет вставок в середину.\n\nПредпочтительно использовать **стабильный уникальный id**.\n\n---\n\n### Контролируемые vs неконтролируемые компоненты (формы)\n\n**Контролируемый компонент** — значение берётся из состояния React.\n\n```tsx\nfunction NameInput() {\n  const [value, setValue] = useState('');\n\n  return (\n    <input\n      value={value}\n      onChange={e => setValue(e.target.value)}\n    />\n  );\n}\n```\n\n- Источник истины — состояние компонента.\n- Легче валидировать, сбрасывать, синхронизировать.\n\n**Неконтролируемый компонент** — читаем значение через ref:\n\n```tsx\nfunction NameForm() {\n  const inputRef = useRef<HTMLInputElement | null>(null);\n\n  const handleSubmit = () => {\n    console.log(inputRef.current?.value);\n  };\n\n  return <input ref={inputRef} />;\n}\n```\n\nИспользуется реже; бывает удобен для интеграции со сторонними библиотеками.",
        "keyPoints": [
          "React думает категориями: UI = функция от состояния",
          "JSX — синтаксический сахар над React.createElement с отличиями от HTML",
          "Компонент — это функция, принимающая пропсы и возвращающая JSX",
          "Для списков обязательно нужны корректные key, лучше стабильные id, а не индекс",
          "Контролируемые компоненты управляют значением через состояние React"
        ]
      },
      "practice": [
        "Создайте простой компонент TodoList, который рендерит список дел из массива объектов, используя корректные key.",
        "Сделайте форму добавления нового дела: контролируемый input + кнопка \"Добавить\", по клику задача добавляется в список.",
        "Потренируйтесь менять HTML-код на JSX: возьмите произвольный фрагмент HTML и перепишите его в JSX с корректными атрибутами."
      ],
      "quiz": [
        {
          "id": 76,
          "question": "Что возвращает функциональный компонент в React?",
          "options": [
            { "id": "opt-76-1", "opt": "Только строку" },
            { "id": "opt-76-2", "opt": "JSX или React-элемент" },
            { "id": "opt-76-3", "opt": "Только DOM-элемент" },
            { "id": "opt-76-4", "opt": "Всегда null" }
          ],
          "correctAnswer": "opt-76-2",
          "explanation": "Компонент возвращает JSX (который компилируется в React-элемент). React уже сам обновляет DOM."
        },
        {
          "id": 77,
          "question": "Какое имя атрибута нужно использовать в JSX вместо class?",
          "options": [
            { "id": "opt-77-1", "opt": "class" },
            { "id": "opt-77-2", "opt": "className" },
            { "id": "opt-77-3", "opt": "cssClass" },
            { "id": "opt-77-4", "opt": "styleClass" }
          ],
          "correctAnswer": "opt-77-2",
          "explanation": "В JSX используется className, так как class — ключевое слово в JS."
        },
        {
          "id": 78,
          "question": "Зачем в списках React нужны ключи (key)?",
          "options": [
            { "id": "opt-78-1", "opt": "Чтобы изменить стили элементов" },
            {
              "id": "opt-78-2",
              "opt": "Чтобы React различал элементы между рендерами и корректно обновлял DOM"
            },
            { "id": "opt-78-3", "opt": "Чтобы сортировать массив" },
            { "id": "opt-78-4", "opt": "Без ключей JSX не скомпилируется" }
          ],
          "correctAnswer": "opt-78-2",
          "explanation": "key помогает React сопоставлять элементы списка между рендерами и переиспользовать DOM-узлы."
        },
        {
          "id": 79,
          "question": "Какое утверждение про контролируемые компоненты верно?",
          "options": [
            {
              "id": "opt-79-1",
              "opt": "Их значение хранится в DOM и читается через ref"
            },
            {
              "id": "opt-79-2",
              "opt": "Они не поддерживаются в функциональных компонентах"
            },
            {
              "id": "opt-79-3",
              "opt": "Их значение хранится в состоянии React и обновляется через onChange"
            },
            {
              "id": "opt-79-4",
              "opt": "Контролируемые компоненты — это только select и checkbox"
            }
          ],
          "correctAnswer": "opt-79-3",
          "explanation": "Контролируемый компонент берёт значение из state и изменяет его через обработчики событий."
        },
        {
          "id": 80,
          "question": "Почему не рекомендуется всегда использовать индекс массива как key?",
          "options": [
            { "id": "opt-80-1", "opt": "Индексы нельзя использовать в JSX" },
            { "id": "opt-80-2", "opt": "Это замедляет работу React" },
            {
              "id": "opt-80-3",
              "opt": "Это может привести к неправильному переиспользованию элементов при вставке/удалении"
            },
            {
              "id": "opt-80-4",
              "opt": "Индекс доступен только в for, но не в map"
            }
          ],
          "correctAnswer": "opt-80-3",
          "explanation": "При изменении порядка или вставке элементов React может \"перепутать\" компоненты, что вызывает странные баги."
        }
      ]
    },
    {
      "id": 17,
      "title": "React Hooks: useState, useEffect, данные и побочные эффекты",
      "duration": "170 мин",
      "theory": {
        "topics": [
          "useState и работа с состоянием",
          "Правила хуков",
          "useEffect: зависимости, cleanup, типичные паттерны",
          "Фетчинг данных в useEffect",
          "Антипаттерны и частые вопросы на собеседованиях про эффекты"
        ],
        "content": "### useState\n\nХук `useState` добавляет состояние в функциональный компонент.\n\n```tsx\nconst [count, setCount] = useState(0);\n\nconst increment = () => setCount(prev => prev + 1);\n```\n\nРекомендации:\n- используйте форму `setState(prev => ...)`, когда новое значение зависит от предыдущего;\n- старайтесь хранить в state **минимум необходимой информации** (derived state не дублируем).\n\nПример derived state (то, что делать *не надо*):\n\n```tsx\n// плохо\nconst [firstName, setFirstName] = useState('');\nconst [lastName, setLastName] = useState('');\nconst [fullName, setFullName] = useState('');\n\nuseEffect(() => {\n  setFullName(firstName + ' ' + lastName);\n}, [firstName, lastName]);\n```\n\nЛучше вычислять `fullName` на лету:\n\n```tsx\nconst fullName = firstName + ' ' + lastName;\n```\n\n---\n\n### Правила хуков\n\n1. **Вызывать хуки только на верхнем уровне компонента**.\n   - не внутри условий,\n   - не внутри циклов,\n   - не внутри вложенных функций.\n\n2. **Вызывать хуки только из React-компонентов или кастомных хуков**.\n\nЭто нужно, чтобы React мог правильно сопоставлять состояние между рендерами.\n\n---\n\n### useEffect: побочные эффекты\n\n`useEffect` запускает побочный эффект после рендера.\n\n```tsx\nuseEffect(() => {\n  console.log('Компонент смонтирован или обновлён');\n});\n```\n\nСписок зависимостей управляет, **когда** эффект запускается:\n\n- без массива зависимостей — после каждого рендера;\n- пустой массив `[]` — только после первого рендера (аналог componentDidMount);\n- `[value]` — при первом рендере и каждом изменении `value`.\n\n```tsx\nuseEffect(() => {\n  console.log('value изменилось:', value);\n}, [value]);\n```\n\n---\n\n### Cleanup (очистка)\n\nЭффект может возвращать функцию очистки.\n\n```tsx\nuseEffect(() => {\n  window.addEventListener('resize', handleResize);\n\n  return () => {\n    window.removeEventListener('resize', handleResize);\n  };\n}, []);\n```\n\nОчистка вызывается перед размонтированием и перед повторным запуском эффекта.\n\n---\n\n### Фетчинг данных в useEffect\n\nБазовый паттерн:\n\n```tsx\nfunction UsersList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function load() {\n      try {\n        setLoading(true);\n        setError(null);\n        const res = await fetch('/api/users');\n        if (!res.ok) throw new Error('Request failed');\n        const data = await res.json();\n        if (!cancelled) setUsers(data);\n      } catch (e) {\n        if (!cancelled) setError((e as Error).message);\n      } finally {\n        if (!cancelled) setLoading(false);\n      }\n    }\n\n    load();\n\n    return () => {\n      cancelled = true;\n    };\n  }, []);\n\n  // рендер по состоянию loading/error/users\n}\n```\n\nВопросы на собеседованиях часто касаются:\n- зависимости эффекта (почему бесконечный рендер),\n- как отменять запросы,\n- чем useEffect отличается от события в DOM или колбэка.\n\n---\n\n### Частые антипаттерны useEffect\n\n1. **Лишний эффект для вычислимого значения** (derived state вместо эффекта).\n2. **Несогласованные зависимости** — используем переменную в эффекте, но забываем добавить её в массив.\n3. **Логика, которая должна жить в обработчике события, но помещена в эффект**, из-за чего код выполняется чаще, чем нужно.\n\nХорошее правило: сначала спросить себя: *\"Можно ли сделать это без useEffect?\"*",
        "keyPoints": [
          "useState добавляет состояние в функциональные компоненты, важно не дублировать derived state",
          "Хуки вызываются только на верхнем уровне и только из компонентов/кастомных хуков",
          "useEffect управляет побочными эффектами: запросы, подписки, работа с DOM",
          "Массив зависимостей контролирует частоту выполнения эффекта",
          "Многие вещи можно сделать без useEffect — не стоит использовать его как \"молоток для всего\""
        ]
      },
      "practice": [
        "Реализуйте компонент Counter с кнопками +1, -1 и сбросом. Попробуйте разные варианты обновления состояния (через prev).",
        "Сделайте компонент, который подписывается на событие resize и отображает текущую ширину окна. Не забудьте про cleanup.",
        "Реализуйте компонент, который грузит список постов с публичного API (например, JSONPlaceholder), показывает состояния loading/error и список данных."
      ],
      "quiz": [
        {
          "id": 81,
          "question": "Где можно вызывать React-хуки (useState, useEffect и т.п.)?",
          "options": [
            { "id": "opt-81-1", "opt": "В любом месте, это обычные функции" },
            { "id": "opt-81-2", "opt": "Только внутри классовых компонентов" },
            {
              "id": "opt-81-3",
              "opt": "Только на верхнем уровне функциональных компонентов и кастомных хуков"
            },
            {
              "id": "opt-81-4",
              "opt": "Можно внутри if и циклов, если осторожно"
            }
          ],
          "correctAnswer": "opt-81-3",
          "explanation": "Правила хуков требуют вызывать их только на верхнем уровне компонента или кастомного хука."
        },
        {
          "id": 82,
          "question": "Как сработает useEffect без второго аргумента?",
          "options": [
            { "id": "opt-82-1", "opt": "Только один раз при монтировании" },
            { "id": "opt-82-2", "opt": "Никогда не сработает" },
            {
              "id": "opt-82-3",
              "opt": "Будет выполняться после каждого рендера"
            },
            { "id": "opt-82-4", "opt": "Только при размонтировании" }
          ],
          "correctAnswer": "opt-82-3",
          "explanation": "Без массива зависимостей эффект запускается после каждого рендера компонента."
        },
        {
          "id": 83,
          "question": "Что делает функция, возвращаемая из useEffect?",
          "options": [
            { "id": "opt-83-1", "opt": "Ничего, это просто коллбек" },
            { "id": "opt-83-2", "opt": "Вызывается один раз при монтировании" },
            {
              "id": "opt-83-3",
              "opt": "Является функцией очистки, вызывается перед размонтированием/перезапуском эффекта"
            },
            { "id": "opt-83-4", "opt": "Используется только для логирования" }
          ],
          "correctAnswer": "opt-83-3",
          "explanation": "Функция-\"cleanup\" вызывается перед повторным запуском эффекта и при размонтировании компонента."
        },
        {
          "id": 84,
          "question": "Какой вариант обновления состояния корректен, если новое значение зависит от предыдущего?",
          "options": [
            { "id": "opt-84-1", "opt": "setCount(count + 1)" },
            { "id": "opt-84-2", "opt": "setCount(prev => prev + 1)" },
            { "id": "opt-84-3", "opt": "setCount(count++)" },
            { "id": "opt-84-4", "opt": "setCount(() => count)" }
          ],
          "correctAnswer": "opt-84-2",
          "explanation": "Форма с функцией гарантирует корректное обновление, особенно при нескольких вызовах подряд."
        },
        {
          "id": 85,
          "question": "Почему важно указывать все используемые в эффекте переменные в массиве зависимостей?",
          "options": [
            {
              "id": "opt-85-1",
              "opt": "Иначе useEffect вызовет синтаксическую ошибку"
            },
            {
              "id": "opt-85-2",
              "opt": "Иначе возникнет бесконечный цикл рендеров"
            },
            {
              "id": "opt-85-3",
              "opt": "Иначе эффект может работать со \"старыми\" значениями и вести себя некорректно"
            },
            {
              "id": "opt-85-4",
              "opt": "Это просто рекомендация линтера, не влияющая на поведение"
            }
          ],
          "correctAnswer": "opt-85-3",
          "explanation": "Если не указать зависимость, эффект не будет обновляться при её изменении и может работать с устаревшими значениями."
        }
      ]
    },
    {
      "id": 18,
      "title": "Продвинутый React: производительность, композиция и тестирование",
      "duration": "180 мин",
      "theory": {
        "topics": [
          "Разбиение приложения на компоненты и подъём состояния",
          "Проблема prop drilling и контекст (с точки зрения архитектуры)",
          "Оптимизация: React.memo, useMemo, useCallback",
          "Ленивая загрузка (React.lazy, Suspense)",
          "Основы тестирования компонентов (React Testing Library / Jest, обзорно)"
        ],
        "content": "### Разбиение на компоненты и подъём состояния\n\nЧастые вопросы на собеседовании:\n- как разбить UI на компоненты?\n- где должно жить состояние?\n\nПринципы:\n- один компонент — одна ответственность (UI-кусок или логика);\n- состояние поднимаем (lift state up) **до ближайшего общего предка**, который должен его знать.\n\nПример: у двух дочерних компонентов есть общий фильтр — храните фильтр выше, а вниз передавайте пропсы.\n\n---\n\n### Prop drilling и контекст\n\n**Prop drilling** — когда вы передаёте пропсы через несколько уровней, хотя промежуточные компоненты сами их не используют.\n\nРешения:\n- локальное: не бояться prop drilling, если глубина небольшая;\n- глобальное: контекст или state-менеджер.\n\nКонтекст хорошо подходит для:\n- текущего пользователя;\n- темы (light/dark);\n- языка интерфейса;\n- глобальных настроек.\n\n---\n\n### Оптимизация: React.memo, useMemo, useCallback\n\n**React.memo** — мемоизирует результат рендера компонента по пропсам.\n\n```tsx\nconst UserRow = React.memo(function UserRow({ user }: { user: User }) {\n  console.log('render', user.id);\n  return <div>{user.name}</div>;\n});\n```\n\nКомпонент будет перерендериваться только если меняются его пропсы (по поверхностному сравнению).\n\n**useCallback** — мемоизирует функцию между рендерами.\n\n```tsx\nconst handleClick = useCallback(() => {\n  console.log('clicked');\n}, []);\n```\n\nНужно, когда:\n- вы передаёте колбэк в мемоизированный дочерний компонент;\n- часто пере-рендерятся дети из-за новых ссылок на функции.\n\n**useMemo** — мемоизирует результат вычисления.\n\n```tsx\nconst total = useMemo(() => {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}, [items]);\n```\n\nВажно: оптимизации должны быть **обоснованы**. На собеседовании ожидают, что вы понимаете цену усложнения кода.\n\n---\n\n### Ленивая загрузка компонентов\n\n```tsx\nconst SettingsPage = React.lazy(() => import('./SettingsPage'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <SettingsPage />\n    </Suspense>\n  );\n}\n```\n\nИспользуется для:\n- разделения бандла;\n- загрузки тяжёлых страниц/частей позже.\n\n---\n\n### Основы тестирования React-компонентов\n\nЧасто на собеседовании ждут хотя бы базовое понимание:\n- **Jest** — тест-раннер и assertion-библиотека;\n- **React Testing Library (RTL)** — для тестирования компонентов через пользовательское взаимодействие.\n\nПример (псевдокод, идея):\n\n```tsx\n// Counter.tsx\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <span>{count}</span>\n      <button onClick={() => setCount(c => c + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n```ts\n// Counter.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Counter } from './Counter';\n\ntest('increments counter on click', () => {\n  render(<Counter />);\n\n  const button = screen.getByText('+');\n  fireEvent.click(button);\n\n  expect(screen.getByText('1')).toBeInTheDocument();\n});\n```\n\nФокус: тестируем поведение, а не внутреннюю реализацию.",
        "keyPoints": [
          "Состояние поднимают до ближайшего общего предка компонентов, которые его используют",
          "Prop drilling не всегда зло, но при глубокой вложенности помогает контекст",
          "React.memo, useMemo и useCallback уменьшают лишние рендеры, но добавляют сложность — применять по необходимости",
          "Ленивая загрузка (React.lazy + Suspense) помогает разбивать бандл и ускорять первоначальную загрузку",
          "Тесты компонентов обычно пишут через Jest + React Testing Library, проверяя поведение глазами пользователя"
        ]
      },
      "practice": [
        "Возьмите простой список элементов с фильтром (input + список) и поднимите состояние фильтра в родительский компонент, разделив код на несколько компонентов.",
        "Добавьте в приложение несколько дочерних компонентов и примените React.memo + useCallback, чтобы уменьшить количество лишних рендеров (можно проверить через console.log).",
        "Напишите 1–2 простых теста для компонента (например, формы или счётчика) с использованием подхода RTL: рендер, поиск элементов, имитация кликов/ввода."
      ],
      "quiz": [
        {
          "id": 86,
          "question": "Что такое \"подъём состояния\" (lift state up) в React?",
          "options": [
            { "id": "opt-86-1", "opt": "Перенос состояния в Redux" },
            {
              "id": "opt-86-2",
              "opt": "Перенос состояния в более высокий общий компонент-предок, чтобы несколько дочерних компонентов могли его использовать"
            },
            { "id": "opt-86-3", "opt": "Перенос состояния в localStorage" },
            { "id": "opt-86-4", "opt": "Удаление состояния из компонентов" }
          ],
          "correctAnswer": "opt-86-2",
          "explanation": "Lift state up — классический приём: состояние живёт там, где оно необходимо нескольким детям."
        },
        {
          "id": 87,
          "question": "Для чего используют React.memo?",
          "options": [
            { "id": "opt-87-1", "opt": "Чтобы добавить побочные эффекты" },
            {
              "id": "opt-87-2",
              "opt": "Чтобы мемоизировать компонент и не перерисовывать его при тех же пропсах"
            },
            { "id": "opt-87-3", "opt": "Чтобы заменять классовые компоненты" },
            { "id": "opt-87-4", "opt": "Чтобы работать с контекстом" }
          ],
          "correctAnswer": "opt-87-2",
          "explanation": "React.memo делает компонент \"чистым\" по пропсам: при тех же пропсах он не рендерится заново."
        },
        {
          "id": 88,
          "question": "Чем useCallback отличается от useMemo?",
          "options": [
            {
              "id": "opt-88-1",
              "opt": "useCallback мемоизирует значение, useMemo — функцию"
            },
            { "id": "opt-88-2", "opt": "Это одно и то же" },
            {
              "id": "opt-88-3",
              "opt": "useCallback мемоизирует функцию, useMemo — произвольное значение"
            },
            {
              "id": "opt-88-4",
              "opt": "useCallback используется только с контекстом"
            }
          ],
          "correctAnswer": "opt-88-3",
          "explanation": "useCallback(fn, deps) эквивалентен useMemo(() => fn, deps): первый возвращает функцию, второй — результат вычисления."
        },
        {
          "id": 89,
          "question": "Какой паттерн используется для ленивой загрузки компонента в React?",
          "options": [
            { "id": "opt-89-1", "opt": "React.defer + Fallback" },
            { "id": "opt-89-2", "opt": "React.lazy + Suspense" },
            { "id": "opt-89-3", "opt": "useEffect + setTimeout" },
            {
              "id": "opt-89-4",
              "opt": "Только через Webpack, React не умеет это сам"
            }
          ],
          "correctAnswer": "opt-89-2",
          "explanation": "Стандартный паттерн: React.lazy(() => import(...)) и обёртка в <Suspense fallback={...}>."
        },
        {
          "id": 90,
          "question": "На что делает упор React Testing Library при тестировании компонентов?",
          "options": [
            {
              "id": "opt-90-1",
              "opt": "На проверку внутренних методов и стейта компонента"
            },
            {
              "id": "opt-90-2",
              "opt": "На тестирование DOM и поведения с точки зрения пользователя (текст, клики, ввод)"
            },
            { "id": "opt-90-3", "opt": "Только на снапшот-тесты" },
            { "id": "opt-90-4", "opt": "Только на производительность" }
          ],
          "correctAnswer": "opt-90-2",
          "explanation": "RTL продвигает подход \"test the way users use it\": текст, клики, ввод, а не внутренности компонента."
        }
      ]
    },
    {
      "id": 19,
      "title": "Git и GitHub: рабочий процесс фронтенд-разработчика",
      "duration": "150 мин",
      "theory": {
        "topics": [
          "Зачем фронтендеру Git и GitHub на собеседовании",
          "Базовые команды и типичный flow",
          "Работа с ветками и pull request’ами",
          "Чистая история коммитов и хорошие сообщения",
          "Как оформить GitHub под собеседования"
        ],
        "content": "### Зачем Git фронтендеру\n\nНа собеседовании от junior+/middle ожидают:\n\n- **умение работать с Git в команде**;\n- **понимание базовых команд и ветвления**;\n- **наличие проектов на GitHub/GitLab** — как портфолио.\n\nЧастый вопрос: *\"Расскажите, как вы работаете с Git\"* — важно уметь описать свой workflow.\n\n---\n\n### Базовые команды\n\nМинимальный набор, который нужно знать на уровне \"на автомате\":\n\n```bash\n# инициализация репозитория\ngit init\n\n# добавить файлы в индекс\ngit add .\n\n# создать коммит\ngit commit -m \"feat: add todo list\"\n\n# история коммитов\ngit log --oneline\n\n# подключить удалённый репо\ngit remote add origin git@github.com:user/repo.git\n\n# отправить изменения\ngit push -u origin main\n```\n\nВажно понимать разницу между:\n\n- **working directory** — ваши файлы;\n- **staging area (index)** — подготовленные к коммиту изменения;\n- **repository** — история коммитов.\n\n---\n\n### Ветки и типичный flow\n\nОсновные команды:\n\n```bash\n# создать ветку<branch-name> от текущей\ngit checkout -b feature/login-form\n\n# переключиться на ветку main\ngit checkout main\n\n# слить feature/login-form в main (находясь на main)\ngit merge feature/login-form\n```\n\nУпрощённый рабочий процесс:\n\n1. Забираем свежие изменения с main:\n   ```bash\n   git checkout main\n   git pull\n   ```\n2. Создаём ветку под задачу:\n   ```bash\n   git checkout -b feature/task-123-login-form\n   ```\n3. Работаем, коммитим **маленькими порциями**:\n   ```bash\n   git add src/Login.tsx\n   git commit -m \"feat: add basic login form\"\n   ```\n4. Пушим ветку и создаём Pull Request (PR).\n\nНа собеседовании можно кратко описать именно такой сценарий.\n\n---\n\n### Хорошие сообщения коммитов\n\nПлохой стиль:\n- `\"fix\"`, `\"update\"`, `\"again\"` — непонятно, что именно изменилось.\n\nЛучше использовать префиксы:\n- `feat:`, `fix:`, `refactor:`, `chore:`, `docs:` и т.п.\n\nПримеры:\n\n- `feat: add filter by status to todo list`\n- `fix: handle empty response from API`\n- `refactor: extract TodoItem component`\n\nТакую историю коммитов приятно читать при ревью и приятно показывать на собеседовании.\n\n---\n\n### GitHub как часть портфолио\n\nМинимум, который хорошо иметь к собеседованию:\n\n- 2–3 маленьких, но аккуратных проекта (React/TS, верстка, pet-project);\n- **readme** у каждого проекта:\n  - что за проект;\n  - как запустить (`npm install`, `npm run dev`);\n  - скриншоты или демо-ссылка;\n- понятная структура репозитория: `src/`, `components/`, `pages/`.\n\nЧастый вопрос: *\"Можете показать код\"* — проще всего дать ссылку на GitHub и пройтись по структуре и интересным местам.\n",
        "keyPoints": [
          "Git и GitHub — обязательный инструмент фронтендера и часть вашего портфолио",
          "Нужно уверенно владеть базовыми командами и понимать working dir / stage / repo",
          "Работа с ветками и PR — стандартный командный процесс",
          "Хорошие сообщения коммитов делают историю понятной и приятной",
          "Оформленные проекты на GitHub часто становятся предметом обсуждения на собеседовании"
        ]
      },
      "practice": [
        "Создайте новый репозиторий с небольшим React/TS-проектом (например, todo-листа), настройте README с инструкцией по запуску.",
        "Потренируйтесь в workflow: создайте ветку под задачу, сделайте 2–3 осмысленных коммита, создайте PR (даже если он будет без ревью).",
        "Возьмите один из ваших старых проектов, перепройдите историю коммитов: переименуйте пару совсем непонятных коммитов через интерактивный rebase (для тренировки)."
      ],
      "quiz": [
        {
          "id": 91,
          "question": "За что отвечает команда git add?",
          "options": [
            { "id": "opt-91-1", "opt": "Создаёт новый коммит" },
            {
              "id": "opt-91-2",
              "opt": "Добавляет файлы в staging area (индекс)"
            },
            {
              "id": "opt-91-3",
              "opt": "Отправляет изменения на удалённый репозиторий"
            },
            { "id": "opt-91-4", "opt": "Создаёт новую ветку" }
          ],
          "correctAnswer": "opt-91-2",
          "explanation": "git add добавляет изменения в staging area — подготавливает их к созданию коммита."
        },
        {
          "id": 92,
          "question": "Какой из вариантов — хороший пример сообщения коммита?",
          "options": [
            { "id": "opt-92-1", "opt": "fix" },
            { "id": "opt-92-2", "opt": "update code" },
            { "id": "opt-92-3", "opt": "feat: add search field to header" },
            { "id": "opt-92-4", "opt": "changes" }
          ],
          "correctAnswer": "opt-92-3",
          "explanation": "Сообщение должно кратко и конкретно описывать *что* сделано: тип + короткое описание."
        },
        {
          "id": 93,
          "question": "Какой командой обычно отправляют локальную ветку на GitHub впервые?",
          "options": [
            { "id": "opt-93-1", "opt": "git push origin" },
            { "id": "opt-93-2", "opt": "git push -u origin <branch-name>" },
            { "id": "opt-93-3", "opt": "git upload" },
            { "id": "opt-93-4", "opt": "git send" }
          ],
          "correctAnswer": "opt-93-2",
          "explanation": "Флаг -u связывает локальную ветку с удалённой, чтобы дальше можно было писать просто git push."
        },
        {
          "id": 94,
          "question": "Что из этого верно про ветки в Git?",
          "options": [
            {
              "id": "opt-94-1",
              "opt": "Ветки — это отдельные копии репозитория на диске"
            },
            {
              "id": "opt-94-2",
              "opt": "Ветки — это указатели на конкретные коммиты в истории"
            },
            {
              "id": "opt-94-3",
              "opt": "Ветка может существовать только одна — main"
            },
            {
              "id": "opt-94-4",
              "opt": "Ветки существуют только на GitHub, локально их нет"
            }
          ],
          "correctAnswer": "opt-94-2",
          "explanation": "Ветка — это по сути указатель на коммит, который двигается по мере новых коммитов."
        },
        {
          "id": 95,
          "question": "Зачем фронтендеру оформленный GitHub на собеседовании?",
          "options": [
            {
              "id": "opt-95-1",
              "opt": "Без GitHub не возьмут на работу юридически"
            },
            {
              "id": "opt-95-2",
              "opt": "Это демонстрирует реальный код, структуру проектов и умение работать с инструментами"
            },
            {
              "id": "opt-95-3",
              "opt": "Только чтобы показать количество звёзд на репозиториях"
            },
            { "id": "opt-95-4", "opt": "Никакой пользы нет, это формальность" }
          ],
          "correctAnswer": "opt-95-2",
          "explanation": "GitHub — живое портфолио: по нему видно стиль кода, умение пользоваться Git и структуру проектов."
        }
      ]
    },
    {
      "id": 20,
      "title": "Chrome DevTools, отладка и базовая оптимизация",
      "duration": "160 мин",
      "theory": {
        "topics": [
          "Обзор вкладок Chrome DevTools, которые реально нужны фронтендеру",
          "Отладка JavaScript: breakpoints, watch, call stack",
          "Анализ верстки и адаптива во вкладке Elements",
          "Network, Performance и Lighthouse: поиск узких мест",
          "Типичные вопросы по DevTools и performance на собеседованиях"
        ],
        "content": "### Зачем учить DevTools\n\nНа реальной работе и на собеседовании вас редко просят \"наизусть\" знать все вкладки DevTools, но ожидают, что вы:\n\n- умеете **искать и чинить баги в JS и верстке**;\n- понимаете, где смотреть ошибки запросов;\n- можете показать, как исследовать проблему в performance.\n\nПоказать уверенное владение DevTools — хороший плюс на интервью.\n\n---\n\n### Основные вкладки DevTools\n\n1. **Elements** — DOM-дерево и стили:\n   - просмотр/правка HTML и CSS;\n   - просмотр computed-стилей;\n   - responsive mode (эмуляция мобилок);\n   - поиск наложенных стилей, специфичности.\n\n2. **Console** — логирование и ошибки:\n   - `console.log`, `console.error`, `console.table`;\n   - просмотр ошибок JS и предупреждений.\n\n3. **Sources** — отладка кода:\n   - breakpoints, шаги исполнения, watch-выражения;\n   - просмотр call stack;\n   - возможность редактировать код \"на лету\" (для быстрых проверок).\n\n4. **Network** — запросы:\n   - статус-коды (200, 404, 500...);\n   - заголовки, payload, response;\n   - время ответа, размер;\n   - фильтрация XHR/fetch.\n\n5. **Performance / Lighthouse** — базовый анализ производительности и качества.\n\n---\n\n### Отладка JavaScript: breakpoints и call stack\n\nВместо бесконечного `console.log` лучше уметь ставить **точки останова**.\n\nШаги:\n1. Откройте вкладку **Sources**.\n2. Найдите нужный файл (или используйте `Cmd+P` / `Ctrl+P`).\n3. Кликните по номеру строки — поставится breakpoint.\n4. Воспроизведите действие в UI, чтобы код дошёл до этой строки.\n\nДальше можно:\n- смотреть значения переменных (hover, вкладка Scope);\n- смотреть стек вызовов (Call stack);\n- шагать по коду (Step over, Step into).\n\nНа собеседовании это можно кратко проговорить и при случае показать на практике.\n\n---\n\n### Elements: верстка, box-model и responsive\n\nВо вкладке **Elements** важно:\n\n- смотреть структуру DOM и иерархию;\n- изучать **box model** элемента (margin, border, padding, content);\n- выяснять, почему что-то не кликается (оверлей, z-index, pointer-events);\n- включать **Device toolbar** (иконка мобилки), чтобы:\n  - проверять breakpoints;\n  - смотреть, как ведёт себя layout на разных ширинах.\n\n---\n\n### Network и Performance\n\n**Network** помогает:\n\n- увидеть, ушёл ли запрос вообще;\n- понять статус-код и текст ошибки;\n- посмотреть payload (что мы отправили) и response (что получили);\n- увидеть, нет ли лишних тяжёлых ресурсов.\n\n**Performance / Lighthouse** (на базовом уровне):\n\n- время первого рендера;\n- тяжёлые скрипты;\n- блокирующие ресурсы;\n- метрики LCP, CLS (можно хотя бы знать, что это — показатели пользовательского опыта).\n\nНа уровне junior+/middle ожидают хотя бы понимания: \"где смотреть, если страница тормозит\".\n\n---\n\n### Типичные вопросы на собеседовании\n\n- *\"Как вы дебажите JavaScript-код?\"* — рассказ про DevTools, breakpoints, console.\n- *\"Как найдете, почему запрос возвращает ошибку?\"* — вкладка Network.\n- *\"Как проверить адаптивность и верстку под мобильные устройства?\"* — Device toolbar в Elements.\n- *\"Как бы вы начали разбирать проблему с производительностью фронтенда?\"* — Performance/Lighthouse, размер бандла, количество запросов, heavy JS.",
        "keyPoints": [
          "DevTools — основной инструмент для отладки и анализа поведения фронтенда",
          "Breakpoints и call stack дают гораздо более контролируемую отладку, чем хаотичные console.log",
          "Elements помогает диагностировать верстку, box model и адаптив",
          "Network — главный источник информации о проблемах с запросами",
          "Базовое понимание Performance/Lighthouse показывает, что вы думаете о производительности"
        ]
      },
      "practice": [
        "Возьмите любой свой проект и найдите 2–3 места, где можно поставить breakpoints, чтобы понять порядок выполнения кода (например, обработчик клика или загрузка данных).",
        "Откройте DevTools → Network, перезагрузите страницу и проанализируйте 3–4 запроса: статус, размер, время ответа, payload/response.",
        "Сделайте скриншоты отчёта Lighthouse для своего проекта (Performance/Best Practices/Accessibility) и сформулируйте 2–3 пункта, что бы вы улучшили."
      ],
      "quiz": [
        {
          "id": 96,
          "question": "На какой вкладке DevTools вы будете смотреть статус-код и тело HTTP-запроса?",
          "options": [
            { "id": "opt-96-1", "opt": "Elements" },
            { "id": "opt-96-2", "opt": "Console" },
            { "id": "opt-96-3", "opt": "Network" },
            { "id": "opt-96-4", "opt": "Sources" }
          ],
          "correctAnswer": "opt-96-3",
          "explanation": "Все детали запросов (статусы, заголовки, payload, response) находятся на вкладке Network."
        },
        {
          "id": 97,
          "question": "Что делает breakpoint в DevTools?",
          "options": [
            { "id": "opt-97-1", "opt": "Удаляет строку кода" },
            { "id": "opt-97-2", "opt": "Временно комментирует участок кода" },
            {
              "id": "opt-97-3",
              "opt": "Останавливает выполнение кода на строке для пошаговой отладки"
            },
            { "id": "opt-97-4", "opt": "Перезапускает приложение" }
          ],
          "correctAnswer": "opt-97-3",
          "explanation": "Точка остановки приостанавливает выполнение, чтобы вы могли изучить состояние."
        },
        {
          "id": 98,
          "question": "Где удобнее всего проверить, как верстка выглядит на разных ширинах экрана?",
          "options": [
            { "id": "opt-98-1", "opt": "Только на отдельных устройствах" },
            {
              "id": "opt-98-2",
              "opt": "В Elements с включённым Device toolbar (иконка мобилки)"
            },
            { "id": "opt-98-3", "opt": "На вкладке Console" },
            { "id": "opt-98-4", "opt": "Через Network throttling" }
          ],
          "correctAnswer": "opt-98-2",
          "explanation": "Device toolbar позволяет эмулировать разные viewport’ы и устройства."
        },
        {
          "id": 99,
          "question": "Зачем использовать вкладку Performance/Lighthouse?",
          "options": [
            { "id": "opt-99-1", "opt": "Чтобы редактировать HTML" },
            { "id": "opt-99-2", "opt": "Чтобы смотреть историю Git-коммитов" },
            {
              "id": "opt-99-3",
              "opt": "Чтобы оценить производительность и качество страницы"
            },
            { "id": "opt-99-4", "opt": "Чтобы дебажить CSS-переменные" }
          ],
          "correctAnswer": "opt-99-3",
          "explanation": "Performance и Lighthouse помогают измерить скорость и найти bottleneck’и фронтенда."
        },
        {
          "id": 100,
          "question": "Какой инструмент DevTools удобнее всего использовать, чтобы понять, почему элемент не кликается (перекрыт другим блоком)?",
          "options": [
            { "id": "opt-100-1", "opt": "Console" },
            { "id": "opt-100-2", "opt": "Elements + инспектор (лупа)" },
            { "id": "opt-100-3", "opt": "Network" },
            { "id": "opt-100-4", "opt": "Application" }
          ],
          "correctAnswer": "opt-100-2",
          "explanation": "Инспектор во вкладке Elements позволяет увидеть, какой элемент реально под курсором, и его стили."
        }
      ]
    },
    {
      "id": 21,
      "title": "Стратегия собеседований, разбор форматов и итоговый проект",
      "duration": "180 мин",
      "theory": {
        "topics": [
          "Типы собеседований: скрининг, техинтервью, live-coding, system design, culture fit",
          "Как презентовать себя и проекты (STAR, портфолио, GitHub)",
          "Live-coding и задачи: как думать вслух и не паниковать",
          "Вопросы к интервьюеру, офферы и отказы",
          "План итогового проекта и как его показать на интервью"
        ],
        "content": "### Форматы собеседований\n\nЧастые форматы для junior+/middle frontend:\n\n1. **HR/скрининг** — разговор про опыт, мотивацию, ожидания по зарплате.\n2. **Техинтервью** — вопросы по JS/TS/React, иногда теоретические.\n3. **Live-coding / задачки** — алгоритмы, работа с массивами/строками, небольшие компоненты.\n4. **System design / архитектура UI (обзорно)** — как построить SPA, как разделить на компоненты, работа с API.\n5. **Culture fit** — насколько вы подходите команде, ценности, формат работы.\n\nВажно понимать, чего ждать от каждого этапа, чтобы не пугаться неожиданностей.\n\n---\n\n### Самопрезентация и метод STAR\n\nКлассический вопрос: *\"Расскажите о себе\"*.\n\nСтруктура ответа:\n\n1. Кто вы сейчас (стек, уровень, чем занимаетесь).\n2. Кратко про путь (обучение, проекты).\n3. Чем интересна именно эта позиция/компания.\n\nДля описания опыта/кейсов используют **метод STAR**:\n\n- **S**ituation — контекст: где, что за проект;\n- **T**ask — задача: что нужно было сделать;\n- **A**ction — действия: что конкретно сделали вы;\n- **R**esult — результат: цифры, эффекты, чему научились.\n\nПример:\n> *\"На учебном проекте интернет-магазина нам нужно было ускорить загрузку главной страницы (S/T). Я вынес крупные библиотеки в отдельный чанκ, настроил code splitting и заменил неоптимальные картинки на webp (A). В итоге LCP улучшился примерно в 2 раза, приложение перестало тормозить на слабых устройствах (R).\"*\n\n---\n\n### Live-coding и задачки\n\nГлавная цель live-coding — **посмотреть, как вы думаете**, а не получить идеальное решение с первой попытки.\n\nРекомендации:\n\n- проговорите задачу своими словами (*\"Правильно ли я понимаю, что…\"*);\n- начните с простого/brute-force решения;\n- думайте вслух: *\"Сначала я сделаю так… это O(n²), но потом можно оптимизировать…\"*;\n- пишите читаемый код, давайте имена переменным;\n- по окончании: прогоните код на примерах, обсудите edge-cases.\n\nЕсли застряли:\n- спросите, можно ли рассмотреть меньшее подмножество задачи;\n- озвучьте, что именно непонятно, и попытайтесь разделить проблему на части.\n\n---\n\n### Вопросы к интервьюеру, офферы и отказы\n\nИнтервью — **двусторонний процесс**. Вопросы, которые можно задать:\n\n- Как выглядит типичный день разработчика?\n- Как устроен процесс ревью кода?\n- Как вы принимаете технические решения в команде?\n- Как устроен онбординг для новых сотрудников?\n\nЕсли оффер:\n- уточните испытательный срок, формат работы, уровень ответственности;\n- не бойтесь взять время на обдумывание и сравнение офферов.\n\nЕсли отказ:\n- постарайтесь получить фидбек (хотя бы общий);\n- используйте его, чтобы подправить свой план подготовки;\n- не воспринимайте каждый отказ как оценку вашей \"конечной ценности\" — это точка на кривой роста.\n\n---\n\n### Итоговый проект и как его презентовать\n\nИтоговый (или любой pet-project) — отличный материал для обсуждения:\n\n**Что должно быть в проекте для уровня junior+/middle:**\n\n- SPA на React/TypeScript;\n- работа с API (fetch/SWR/RTK Query и т.п.);\n- маршрутизация (React Router / Next.js pages);\n- осмысленная структура компонентов и папок;\n- базовая обработка ошибок и loading-состояний;\n- аккуратный UI (адаптив, компоненты, кнопки/формы).\n\n**Как о нём рассказать на интервью:**\n\n1. Кратко: что делает приложение и для кого оно.\n2. Какие технологии использовали и почему.\n3. 1–2 интересные технические решения (сложный компонент, кастомный хук, оптимизация).\n4. Что бы вы сделали дальше, если было бы время.\n\nЭто даёт интервьюеру понимание вашего мышления и вкуса к архитектуре.",
        "keyPoints": [
          "Важно понимать форматы собеседований и их цели, чтобы готовиться адресно",
          "Самопрезентация и STAR помогают структурированно рассказывать про опыт и проекты",
          "В live-coding главное — думать вслух, начинать с простого решения и уметь обсуждать trade-offs",
          "Интервью — процесс в обе стороны: задавайте вопросы и анализируйте, подходит ли вам команда",
          "Итоговый проект / pet-project — сильный аргумент на собеседовании, если вы умеете его грамотно показать"
        ]
      },
      "practice": [
        "Запишите на диктофон (или видео) ответ на вопрос \"Расскажите о себе\" в формате 1–2 минут. Прослушайте и перепишите, сделав формулировки более чёткими.",
        "Выберите 1–2 своих проекта и подготовьте по ним рассказ в формате STAR (S/T/A/R), выпишите тезисы в виде пунктов.",
        "Проведите имитацию live-coding: возьмите простую задачу (на массивы/строки или маленький React-компонент), включите таймер на 15–20 минут и вслух проговаривайте мысли, пока решаете."
      ],
      "quiz": [
        {
          "id": 101,
          "question": "Какова основная цель live-coding на техинтервью?",
          "options": [
            { "id": "opt-101-1", "opt": "Проверить скорость печати кандидата" },
            {
              "id": "opt-101-2",
              "opt": "Проверить, насколько идеально он помнит синтаксис"
            },
            {
              "id": "opt-101-3",
              "opt": "Посмотреть, как кандидат думает, разбивает задачу и общается"
            },
            {
              "id": "opt-101-4",
              "opt": "Убедиться, что кандидат умеет пользоваться IDE"
            }
          ],
          "correctAnswer": "opt-101-3",
          "explanation": "Интервьюеру важнее ваш процесс мышления и коммуникации, чем идеальный код с первого раза."
        },
        {
          "id": 102,
          "question": "За что отвечает буква R в методе STAR?",
          "options": [
            { "id": "opt-102-1", "opt": "Requirements" },
            { "id": "opt-102-2", "opt": "Result" },
            { "id": "opt-102-3", "opt": "Refactor" },
            { "id": "opt-102-4", "opt": "React" }
          ],
          "correctAnswer": "opt-102-2",
          "explanation": "R — Result: результат ваших действий, желательно с конкретикой (цифры, эффекты, выводы)."
        },
        {
          "id": 103,
          "question": "Как лучше всего начать ответ на вопрос \"Расскажите о себе\"?",
          "options": [
            { "id": "opt-103-1", "opt": "С подробной истории детства" },
            {
              "id": "opt-103-2",
              "opt": "С текущей роли и стека, затем перейти к опыту и мотивации"
            },
            { "id": "opt-103-3", "opt": "С критики предыдущих работодателей" },
            { "id": "opt-103-4", "opt": "С обсуждения уровня зарплаты" }
          ],
          "correctAnswer": "opt-103-2",
          "explanation": "Начать лучше с текущего профиля и постепенно перейти к релевантному опыту и тому, почему вам интересна роль."
        },
        {
          "id": 104,
          "question": "Какой из вопросов уместно задать интервьюеру?",
          "options": [
            {
              "id": "opt-104-1",
              "opt": "Сколько людей вы уже уволили в этом году?"
            },
            {
              "id": "opt-104-2",
              "opt": "Как устроен процесс ревью кода и кто обычно его делает?"
            },
            {
              "id": "opt-104-3",
              "opt": "Могу ли я сразу получить отпуск на месяц после выхода?"
            },
            {
              "id": "opt-104-4",
              "opt": "Почему вы до сих пор используете этот стек, он же устаревший?"
            }
          ],
          "correctAnswer": "opt-104-2",
          "explanation": "Вопрос о процессе ревью показывает интерес к качеству кода и процессам команды."
        },
        {
          "id": 105,
          "question": "Зачем готовить отдельный рассказ про итоговый проект/pet-project к собеседованию?",
          "options": [
            {
              "id": "opt-105-1",
              "opt": "Чтобы не говорить про реальные задачи на работе"
            },
            {
              "id": "opt-105-2",
              "opt": "Потому что интервьюеры интересуются только дизайном приложения"
            },
            {
              "id": "opt-105-3",
              "opt": "Это наглядный пример вашего кода, архитектуры и умения принимать решения"
            },
            { "id": "opt-105-4", "opt": "Только ради красивых скриншотов" }
          ],
          "correctAnswer": "opt-105-3",
          "explanation": "Хорошо подготовленный рассказ про проект даёт интервьюеру много сигналов о ваших навыках и стиле работы."
        }
      ]
    },
    {
      "id": 21,
      "title": "Итоговый проект: трекер собеседований фронтенд-разработчика",
      "duration": "180 мин",
      "theory": {
        "topics": [
          "Цель итогового проекта и его связь с собеседованиями",
          "Описание функционала приложения Interview Tracker",
          "Структура страниц и навигация",
          "Модель данных и работа с состоянием",
          "Как презентовать проект на собеседовании"
        ],
        "content": "### Цель итогового проекта\n\nИтоговый проект — это приложение, которое одновременно:\n\n- прокачивает **React + TypeScript + работу с данными**;\n- демонстрирует понимание архитектуры и состояния;\n- является живым примером, который можно показать на собеседовании.\n\nМы будем делать **Interview Tracker** — трекер вакансий и этапов собеседований.\n\n---\n\n### Краткое описание приложения\n\n**Interview Tracker** — небольшое SPA, в котором пользователь может:\n\n- добавлять вакансии, на которые он откликнулся;\n- фиксировать компанию, позицию, уровень, стек, ссылку на вакансию;\n- отмечать статус по каждому процессу (отклик, скрининг, техинтервью, оффер, отказ и т.д.);\n- добавлять заметки по каждому этапу (что спросили, что улучшить);\n- видеть небольшую статистику: сколько откликов, сколько активных процессов, сколько отказов, конверсия.\n\nЭто приложение логично связано с темой курса (подготовка к собеседованиям) и одновременно показывает рабочий стек фронтендера.\n\n---\n\n### Модель данных\n\nБазовая сущность — **Application** (заявка/процесс):\n\n```ts\nexport type ApplicationStatus =\n  | 'applied'       // отклик отправлен\n  | 'screening'     // скрининг/HR\n  | 'tech'          // техинтервью\n  | 'offer'         // оффер\n  | 'rejected'      // отказ\n  | 'on-hold';      // поставлено на паузу\n\nexport interface Application {\n  id: string;                 // уникальный id\n  company: string;            // название компании\n  position: string;           // позиция/роль\n  level: 'junior' | 'middle' | 'senior';\n  stack: string;              // стек или ключевые технологии\n  link?: string;              // ссылка на вакансию\n  status: ApplicationStatus;  // текущий статус\n  createdAt: string;          // ISO-дата создания\n  updatedAt: string;          // ISO-дата последнего обновления\n  notes?: string;             // заметки по процессу\n}\n```\n\nПо желанию можно добавить вспомогательные сущности (например, словарь этапов с датами), но базовый вариант опирается на один тип `Application`.\n\n---\n\n### Страницы и навигация\n\nПриложение может быть одностраничным с условным рендерингом или с роутингом (React Router / Next.js). Минимальный набор экранов:\n\n1. **Dashboard (главная страница)**\n   - список всех заявок в виде таблицы/карточек;\n   - фильтры по статусу (\"active\", \"rejected\", \"offer\" и т.д.);\n   - краткая статистика: количество по статусам.\n\n2. **Application Form (страница/модалка создания/редактирования)**\n   - форма для создания новой заявки;\n   - возможность редактировать существующую (prefill формы).\n\n3. **Application Details (детальный просмотр)**\n   - основные поля заявки;\n   - блок заметок по собеседованиям;\n   - таймлайн изменения статусов (опционально).\n\nНавигация может быть реализована через:\n\n- React Router (например, `/`, `/applications/new`, `/applications/:id`);\n- или через локальное состояние, если роутинг пока избыточен.\n\n---\n\n### Состояние и хранение данных\n\nМинимальный вариант:\n\n- хранить массив `Application[]` в состоянии верхнего компонента или в контексте;\n- сохранять данные в `localStorage`, чтобы они не терялись при перезагрузке.\n\nПример структуры состояния:\n\n```ts\ninterface AppState {\n  applications: Application[];\n}\n```\n\nБазовые операции:\n\n- `addApplication(payload)` — добавить новую заявку;\n- `updateApplication(id, patch)` — обновить существующую;\n- `removeApplication(id)` — удалить;\n- `changeStatus(id, status)` — поменять статус.\n\nДля хранения можно сделать кастомный хук, например `useApplications()`, который:\n\n- инкапсулирует логику чтения/записи в `localStorage`;\n- предоставляет методы работы с данными;\n- возвращает состояние и экшены.\n\n---\n\n### Технологический стек (минимальные требования)\n\n- **React** (hooks);\n- **TypeScript** (строгая типизация сущностей и пропсов);\n- CSS / CSS Modules / любой знакомый тебе подход к стилям;\n- сохранение данных хотя бы в `localStorage`.\n\nОпционально (но это плюс на собеседовании):\n\n- роутинг (React Router / Next.js);\n- тесты 1–2 ключевых компонент (Jest + React Testing Library);\n- базовые проверки доступности (aria-атрибуты, фокус, семантика).\n\n---\n\n### Как презентовать проект на собеседовании\n\nСтруктура презентации:\n\n1. **Что делает приложение** и зачем оно нужно.\n2. **Какие технологии** использованы и почему (React, TS, localStorage, контекст и т.д.).\n3. **Как устроены данные и состояние** (Application, где живёт массив, как обновляется).\n4. **Что было сложным/интересным**: например, фильтрация, форма с валидацией, контекст, сохранение в localStorage.\n5. **Что бы ты улучшил/а дальше**: авторизация, синхронизация с реальным API, drag-and-drop по колонкам (kanban-стиль), напоминания о датах интервью.\n",
        "keyPoints": [
          "Итоговый проект — Interview Tracker, трекер вакансий и собеседований",
          "Главная сущность — Application с полями компании, позиции, статуса, заметок и дат",
          "Минимальные страницы: Dashboard, форма создания/редактирования и детальный просмотр",
          "Состояние можно хранить в верхнем компоненте или контексте с сохранением в localStorage",
          "На собеседовании важно уметь кратко объяснить функционал, архитектуру и сделанные технические решения по проекту"
        ]
      },
      "practice": [
        "Создай новый React + TypeScript проект (Vite/CRA/Next — любой знакомый тебе шаблон) с базовой структурой src/ (components/, pages/ или аналогом).",
        "Определи TypeScript-типы: ApplicationStatus и Application, вынеси их в отдельный файл (например, `types/application.ts`).",
        "Реализуй хранилище заявок: состояние `applications: Application[]` + функции add/update/delete/changeStatus. Сначала можно хранить только в state, затем добавить синхронизацию с localStorage.",
        "Собери минимум три экрана: Dashboard со списком и фильтрами, форму создания/редактирования заявки (отдельная страница или модалка) и страницу деталей заявки.",
        "Добавь интерфейсные детали: базовую валидацию формы (обязательные поля), визуальные метки статусов, простую статистику по количеству заявок в каждом статусе на Dashboard.",
        "Подготовь короткий сценарий презентации проекта (3–5 минут): опиши цель, стек, структуру данных и 1–2 интересных решения. Прогоняй его вслух, как будто рассказываешь интервьюеру."
      ],
      "quiz": [
        {
          "id": 101,
          "question": "Зачем в итоговом проекте вводить отдельный тип Application с чётко описанными полями?",
          "options": [
            {
              "id": "opt-101-1",
              "opt": "Чтобы сделать код короче и избежать комментариев"
            },
            {
              "id": "opt-101-2",
              "opt": "Чтобы TypeScript мог помогать при работе с сущностью и чтобы было понятно, какие данные хранит приложение"
            },
            {
              "id": "opt-101-3",
              "opt": "Только ради того, чтобы пройти линтер"
            },
            { "id": "opt-101-4", "opt": "Это обязательное требование React" }
          ],
          "correctAnswer": "opt-101-2",
          "explanation": "Явный тип Application делает структуру данных прозрачной и позволяет TS ловить ошибки при работе с этими объектами."
        },
        {
          "id": 102,
          "question": "Почему для хранения списка заявок удобно использовать отдельный контекст или верхний уровень состояния, а не держать всё в одном компоненте-странице?",
          "options": [
            {
              "id": "opt-102-1",
              "opt": "Так приложение автоматически станет быстрее"
            },
            {
              "id": "opt-102-2",
              "opt": "Иначе React не позволит использовать useState"
            },
            {
              "id": "opt-102-3",
              "opt": "Это упрощает шаринг данных между разными экранами/компонентами (Dashboard, Details, форма)"
            },
            { "id": "opt-102-4", "opt": "Так проще подключить jQuery" }
          ],
          "correctAnswer": "opt-102-3",
          "explanation": "Общее состояние выше по дереву позволяет нескольким страницам и компонентам работать с одним и тем же списком заявок без жёсткого prop drilling."
        },
        {
          "id": 103,
          "question": "Какое преимущество даёт сохранение заявок в localStorage по сравнению с чисто in-memory state?",
          "options": [
            { "id": "opt-103-1", "opt": "Код хуже поддерживать, но так надо" },
            {
              "id": "opt-103-2",
              "opt": "Данные сохраняются между перезагрузками страницы, пользователь не теряет свой прогресс"
            },
            {
              "id": "opt-103-3",
              "opt": "Приложение начинает работать офлайн без каких-либо ограничений"
            },
            {
              "id": "opt-103-4",
              "opt": "Это единственный способ хранить массивы в React"
            }
          ],
          "correctAnswer": "opt-103-2",
          "explanation": "localStorage позволяет восстанавливать состояние (список заявок) после перезагрузки, что приближает поведение к реальному рабочему приложению."
        },
        {
          "id": 104,
          "question": "Какой из экранов лучше всего демонстрирует умение работать с фильтрацией и derived state?",
          "options": [
            { "id": "opt-104-1", "opt": "Настройки темы приложения" },
            { "id": "opt-104-2", "opt": "Страница 404" },
            {
              "id": "opt-104-3",
              "opt": "Dashboard со списком заявок и фильтрами по статусу/компании"
            },
            { "id": "opt-104-4", "opt": "Страница логина с одной кнопкой" }
          ],
          "correctAnswer": "opt-104-3",
          "explanation": "Именно Dashboard показывает умение фильтровать данные, считать статистики и аккуратно работать с производными значениями."
        },
        {
          "id": 105,
          "question": "Что важно подчеркнуть, презентуя этот проект на собеседовании?",
          "options": [
            {
              "id": "opt-105-1",
              "opt": "Только внешний вид и цвета, без деталей реализации"
            },
            {
              "id": "opt-105-2",
              "opt": "Только то, что проект написан быстро"
            },
            {
              "id": "opt-105-3",
              "opt": "Цель приложения, стек (React/TS), структуру данных и ключевые технические решения: хранение состояния, фильтрация, сохранение в localStorage"
            },
            {
              "id": "opt-105-4",
              "opt": "Количество файлов и строк кода в репозитории"
            }
          ],
          "correctAnswer": "opt-105-3",
          "explanation": "Интервьюеру интересно, как вы думали над архитектурой и реализацией, а не просто как выглядит UI или сколько строк кода в проекте."
        }
      ]
    }
  ]
}
